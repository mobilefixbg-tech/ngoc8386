<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Ng·ªçc Ph√°t T√†i 1990</title>

    <style>
        :root{
            --ui-font-size:13px;
        }
        html,body{
            margin:0;
            height:100%;
            display:flex;
            flex-direction:column;
            font-family:Arial;
            overflow:hidden;
            background:#ffffff;
            color:#000;
        }

        .navbar{
            display:flex;align-items:center;
            background:#e8eaed;padding:6px;
        }
        .navbar button{
            margin-right:6px;padding:6px 10px;
            border:none;border-radius:6px;background:#d2d5da;
            font-size:var(--ui-font-size);
        }
        .navbar input{
            flex:1;padding:8px;border-radius:20px;
            border:1px solid #ccc;
            font-size:var(--ui-font-size);
        }
        .zoom-wrap{display:flex;align-items:center;gap:6px;margin-left:8px}
        .zoom-wrap span{font-size:12px;color:#334155;white-space:nowrap}
        .zoom-input{
            width:74px;
            padding:6px 8px;
            border:1px solid #cbd5e1;
            border-radius:8px;
            font-size:12px;
        }
        .brand-script{
            margin-left:10px;
            margin-right:10px;
            font-family:"Brush Script MT","Snell Roundhand","Segoe Script",cursive;
            font-size:28px;
            font-weight:700;
            letter-spacing:0.4px;
            white-space:nowrap;
            background:linear-gradient(90deg,#1e3a8a,#0f766e,#d97706,#be123c,#1e3a8a);
            background-size:300% 300%;
            -webkit-background-clip:text;
            background-clip:text;
            color:transparent;
            animation:brandShift 6s linear infinite;
        }
        @keyframes brandShift{
            0%{background-position:0% 50%}
            50%{background-position:100% 50%}
            100%{background-position:0% 50%}
        }

        .main{flex:1;display:flex;min-height:0;position:relative}
        .main.hidden{display:none}
        #browserArea{flex:1;display:flex;min-height:0}
        webview{flex:1;width:100%;height:100%;display:flex;border:none}
        .history-wrap{padding:10px;border-top:1px solid #ddd;max-height:240px;overflow:auto}
        .history-wrap.hidden{display:none}
        .history-wrap.full-view{flex:1;max-height:none;border-top:none}
        .kqxs-actions{display:flex;justify-content:flex-end;gap:8px;margin-bottom:8px}
        .kqxs-layout-toolbar{display:flex;justify-content:flex-start;gap:6px;margin-bottom:8px;flex-wrap:wrap}
        .kqxs-layout-toolbar button{padding:5px 10px;font-size:12px}
        .kqxs-layout-toolbar .danger-btn{background:#dc2626}
        .kqxs-layout-toolbar .danger-btn:hover{background:#b91c1c}
        .history-boards.drag-active{outline:2px dashed #2563eb;outline-offset:4px}
        .history-boards .history-draw.selected{outline:2px solid #2563eb}
        .scan-btn{
            padding:6px 12px;
            border:none;
            border-radius:6px;
            background:#2563eb;
            color:#fff;
            cursor:pointer;
            font-weight:600;
        }
        .scan-btn:hover{background:#1d4ed8}
        .danger-btn{
            padding:6px 12px;
            border:none;
            border-radius:6px;
            background:#dc2626;
            color:#fff;
            cursor:pointer;
            font-weight:600;
        }
        .danger-btn:hover{background:#b91c1c}
        .top-box{font-size:12px;margin-bottom:8px;color:#0f172a}
        .top-note{font-size:12px;color:#1e3a8a;margin-top:6px}
        .analysis-boards{display:grid;grid-template-columns:1fr;gap:10px}
        .analysis-card{border:1px solid #c9c9c9;background:#e3e3e3}
        .analysis-card-wide{overflow:auto}
        .analysis-title{
            background:#eadfb8;
            text-align:center;
            font-weight:800;
            font-size:20px;
            padding:12px 10px;
        }
        .analysis-station{
            text-align:center;
            font-weight:900;
            font-size:30px;
            color:#1f5ea8;
            padding:8px 10px;
            background:#f3f3f3;
            border-bottom:1px solid #c9c9c9;
            letter-spacing:0.4px;
        }
        .analysis-table{width:100%;border-collapse:collapse;font-size:22px}
        .analysis-table th,.analysis-table td{
            border:1px solid #c9c9c9;
            text-align:center;
            padding:8px;
            background:#dcdcdc;
        }
        .analysis-table th{font-weight:800;color:#333}
        .analysis-number{font-weight:900;color:#c84d00}
        .analysis-columns-table{min-width:720px;font-size:20px}
        .analysis-rank{font-weight:700;color:#334155;white-space:nowrap}
        .analysis-count{font-size:16px;color:#475569;font-weight:600}
        .analysis-smart-grid{
            display:grid;
            grid-template-columns:repeat(3,minmax(0,1fr));
            gap:10px;
        }
        .analysis-subtitle{
            font-size:14px;
            font-weight:700;
            color:#1f2937;
            margin:10px 0 6px;
        }
        .analysis-chip-list{
            display:flex;
            flex-wrap:wrap;
            gap:8px;
            padding:0 8px 10px;
        }
        .analysis-chip{
            border-radius:999px;
            border:1px solid #c9c9c9;
            background:#f3f3f3;
            padding:5px 10px;
            font-size:15px;
            font-weight:700;
            color:#334155;
        }
        .analysis-chip strong{
            color:#c84d00;
            margin-right:4px;
        }
        .analysis-mini-table{
            width:100%;
            border-collapse:collapse;
            font-size:15px;
            margin-top:4px;
        }
        .analysis-mini-table th,.analysis-mini-table td{
            border:1px solid #c9c9c9;
            padding:6px 8px;
            text-align:left;
            background:#dcdcdc;
        }
        .analysis-mini-table th{
            background:#eadfb8;
            font-size:14px;
            color:#334155;
        }
        .analysis-mini-table td:nth-child(1){
            width:34%;
            font-weight:700;
            color:#1f5ea8;
        }
        .analysis-mini-table td:nth-child(n+2){
            font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
            font-weight:700;
            color:#c84d00;
        }
        @media (max-width: 1200px){
            .analysis-smart-grid{grid-template-columns:repeat(2,minmax(0,1fr))}
        }
        @media (max-width: 980px){
            .analysis-smart-grid{grid-template-columns:1fr}
        }
        .history-boards{display:flex;flex-direction:column;gap:10px}
        .history-draw{
            border:1px solid #c9c9c9;
            background:#e3e3e3;
            overflow:auto;
        }
        .history-draw table.layout-editable th{
            cursor:move;
            transition:background 0.2s;
        }
        .history-draw table.layout-editable th:hover{
            background:#bfdbfe;
        }
        .history-draw table.layout-editable th.dragging{
            opacity:0.5;
            background:#93c5fd;
        }
        .history-draw-title{
            background:#eadfb8;
            font-weight:800;
            font-size:18px;
            text-align:center;
            padding:8px;
            border-bottom:1px solid #c9c9c9;
        }
        .result-table{width:100%;border-collapse:collapse}
        .result-table th,.result-table td{
            border:1px solid #d2d2d2;
            text-align:center;
            padding:6px;
            background:#e0e0e0;
            vertical-align:middle;
        }
        .result-table th{font-size:34px;color:#1f5ea8;font-weight:800}
        .result-prize{width:66px;font-size:34px;font-weight:700;color:#3d3d3d}
        .result-values{font-size:48px;font-weight:800;line-height:1.15;color:#333}
        .result-values.db,.result-values.g7{color:#c84d00}
        .copy-raw{
            margin:0;
            white-space:pre-wrap;
            word-break:break-word;
            font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
            line-height:1.5;
        }
        .ticket-card{
            border:1px solid #d1d5db;
            border-radius:8px;
            padding:8px;
            background:#f8fafc;
        }
        .ticket-head{
            font-weight:700;
            margin-bottom:6px;
            color:#0f172a;
        }
        .ticket-meta{
            font-size:12px;
            margin-bottom:6px;
            color:#334155;
        }
        .ticket-tools{
            display:flex;
            justify-content:flex-end;
            margin-bottom:6px;
        }
        .print-ticket-btn{
            padding:4px 10px;
            border:none;
            border-radius:6px;
            background:#ea580c;
            color:#fff;
            font-size:12px;
            font-weight:700;
            cursor:pointer;
        }
        .print-ticket-btn:hover{background:#c2410c}
        .ticket-table{width:100%;border-collapse:collapse}
        .ticket-table th,.ticket-table td{border:1px solid #cbd5e1;padding:6px;text-align:left}
        .ticket-table th{background:#e2e8f0}
        .modal-overlay{
            position:fixed;
            inset:0;
            background:rgba(15,23,42,.5);
            display:none;
            align-items:center;
            justify-content:center;
            z-index:999;
        }
        .modal-overlay.show{display:flex}
        .modal-box{
            width:min(760px,92vw);
            background:#fff;
            border-radius:10px;
            box-shadow:0 10px 30px rgba(2,6,23,.25);
            padding:12px;
        }
        .modal-title{font-weight:700;margin-bottom:8px}
        .modal-box textarea{
            width:100%;
            height:220px;
            border:1px solid #cbd5e1;
            border-radius:8px;
            padding:8px;
            resize:vertical;
            font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
        }
        .modal-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:10px}
        .manual-scan-toolbar{display:flex;gap:6px;margin-bottom:8px}
        .manual-scan-toolbar button{padding:4px 8px;font-size:12px}
        .lens-result-meta{
            margin-bottom:8px;
            font-size:12px;
            color:#334155;
            white-space:pre-wrap;
        }
        .lens-editor-toolbar{
            display:flex;
            align-items:center;
            gap:8px;
            margin-bottom:8px;
            padding:6px;
            background:#f1f5f9;
            border-radius:6px;
        }
        .lens-editor-toolbar span{
            font-size:12px;
            font-weight:600;
            min-width:40px;
            text-align:center;
        }
        .lens-editor-toolbar .ghost-btn{
            padding:4px 8px;
            font-size:12px;
        }
        .lens-editor-toolbar.active{
            background:#dbeafe;
        }
        #lensResultInput.lens-fullscreen{
            height:70vh;
            font-size:16px;
        }
        #lensResultInput.lens-edit-mode{
            font-family:ui-monospace,SFMono-Regular,Menlo,monospace;
            line-height:1.6;
        }
        .lotoai-modal{
            width:min(980px,96vw);
            max-height:94vh;
            overflow:auto;
        }
        .lotoai-toolbar{
            display:grid;
            grid-template-columns:140px minmax(220px,1fr) auto auto auto auto;
            gap:8px;
            margin-bottom:8px;
            align-items:center;
        }
        .lotoai-toolbar select,.lotoai-toolbar input{
            border:1px solid #cbd5e1;
            border-radius:8px;
            padding:6px 8px;
            font-size:12px;
        }
        .lotoai-btn{
            padding:6px 10px;
            border:none;
            border-radius:8px;
            background:#0f766e;
            color:#fff;
            cursor:pointer;
            font-size:12px;
            font-weight:700;
            white-space:nowrap;
        }
        .lotoai-btn:hover{background:#0d9488}
        .lotoai-log{
            border:1px solid #cbd5e1;
            border-radius:10px;
            min-height:280px;
            max-height:50vh;
            overflow:auto;
            padding:10px;
            background:#f8fafc;
            display:flex;
            flex-direction:column;
            gap:8px;
        }
        .lotoai-msg{
            border-radius:10px;
            padding:8px 10px;
            white-space:pre-wrap;
            line-height:1.4;
            font-size:13px;
        }
        .lotoai-msg.user{
            background:#dbeafe;
            align-self:flex-end;
            max-width:88%;
        }
        .lotoai-msg.assistant{
            background:#e2e8f0;
            align-self:flex-start;
            max-width:96%;
        }
        .lotoai-meta{
            margin-top:8px;
            font-size:12px;
            color:#334155;
        }
        .gemini-float-btn{
            position:fixed;
            bottom:20px;
            right:20px;
            width:56px;
            height:56px;
            border-radius:50%;
            background:linear-gradient(135deg,#667eea,#764ba2);
            border:none;
            color:#fff;
            font-size:24px;
            cursor:pointer;
            box-shadow:0 4px 15px rgba(102,126,234,0.4);
            z-index:9998;
            display:flex;
            align-items:center;
            justify-content:center;
            transition:transform 0.2s,box-shadow 0.2s;
        }
        .gemini-float-btn:hover{
            transform:scale(1.1);
            box-shadow:0 6px 20px rgba(102,126,234,0.5);
        }
        .gemini-float-panel{
            position:fixed;
            bottom:85px;
            right:20px;
            width:320px;
            max-height:450px;
            background:#fff;
            border-radius:16px;
            box-shadow:0 8px 30px rgba(0,0,0,0.15);
            z-index:9999;
            display:none;
            flex-direction:column;
            overflow:hidden;
        }
        .gemini-float-panel.show{
            display:flex;
        }
        .gemini-float-header{
            padding:12px;
            background:linear-gradient(135deg,#667eea,#764ba2);
            color:#fff;
            display:flex;
            justify-content:space-between;
            align-items:center;
        }
        .gemini-float-header span{
            font-weight:700;
            font-size:14px;
        }
        .gemini-float-close{
            background:none;
            border:none;
            color:#fff;
            font-size:18px;
            cursor:pointer;
            padding:0;
            line-height:1;
        }
        .gemini-float-body{
            flex:1;
            overflow-y:auto;
            padding:10px;
            background:#f8fafc;
            display:flex;
            flex-direction:column;
            gap:8px;
            min-height:200px;
            max-height:300px;
        }
        .gemini-float-input-wrap{
            padding:10px;
            border-top:1px solid #e2e8f0;
            display:flex;
            gap:8px;
        }
        .gemini-float-input{
            flex:1;
            padding:8px 10px;
            border:1px solid #cbd5e1;
            border-radius:8px;
            font-size:13px;
            resize:none;
            height:38px;
            font-family:inherit;
        }
        .gemini-float-send{
            padding:8px 14px;
            background:#667eea;
            color:#fff;
            border:none;
            border-radius:8px;
            cursor:pointer;
            font-weight:600;
            font-size:13px;
        }
        .gemini-float-send:hover{background:#5a6fd6}
        .gemini-float-send:disabled{background:#94a3b8;cursor:not-allowed}
        .gemini-float-meta{
            padding:8px 12px;
            font-size:11px;
            color:#64748b;
            background:#f1f5f9;
            border-top:1px solid #e2e8f0;
        }
        @media (max-width: 980px){
            .lotoai-toolbar{
                grid-template-columns:1fr;
            }
        }
        .ghost-btn{
            padding:6px 12px;
            border:1px solid #cbd5e1;
            background:#fff;
            border-radius:6px;
            cursor:pointer;
            font-size:var(--ui-font-size);
        }
        .settings-modal{
            width:min(900px,96vw);
            max-height:92vh;
            overflow:auto;
        }
        .settings-tabs{
            display:flex;
            gap:8px;
            margin-bottom:12px;
            border-bottom:1px solid #e2e8f0;
            padding-bottom:8px;
        }
        .settings-tab{
            padding:6px 12px;
            border:1px solid #cbd5e1;
            background:#f8fafc;
            border-radius:8px;
            cursor:pointer;
            font-weight:700;
            font-size:var(--ui-font-size);
        }
        .settings-tab.active{
            background:#1d4ed8;
            color:#fff;
            border-color:#1d4ed8;
        }
        .settings-panel{display:none}
        .settings-panel.show{display:block}
        .settings-grid{
            display:grid;
            grid-template-columns:repeat(2,minmax(0,1fr));
            gap:12px;
        }
        .settings-field{
            display:flex;
            flex-direction:column;
            gap:6px;
        }
        .settings-field label{
            font-size:12px;
            color:#334155;
            font-weight:700;
        }
        .settings-field input,.settings-field select{
            border:1px solid #cbd5e1;
            border-radius:8px;
            padding:8px;
            font-size:var(--ui-font-size);
        }
        .settings-inline{
            display:flex;
            align-items:center;
            gap:8px;
            font-size:var(--ui-font-size);
        }
        .settings-inline input[type="checkbox"]{
            width:16px;
            height:16px;
        }
        .ai-tools-list{
            margin-top:12px;
            display:flex;
            flex-direction:column;
            gap:8px;
        }
        .ai-tool-row{
            border:1px solid #cbd5e1;
            border-radius:10px;
            padding:10px;
            display:grid;
            grid-template-columns:auto minmax(120px,180px) minmax(180px,1fr) auto;
            gap:8px;
            align-items:center;
        }
        .ai-tool-row input[type="text"]{
            width:100%;
            border:1px solid #cbd5e1;
            border-radius:8px;
            padding:6px 8px;
            font-size:var(--ui-font-size);
        }
        .ai-open-btn{
            padding:6px 10px;
            border:none;
            border-radius:8px;
            background:#0f766e;
            color:#fff;
            cursor:pointer;
            font-size:var(--ui-font-size);
            font-weight:700;
        }
        .ai-open-btn:hover{background:#0d9488}
        .settings-actions-grid{
            display:grid;
            grid-template-columns:repeat(3,minmax(0,1fr));
            gap:8px;
        }
        .settings-action-btn{
            padding:8px 10px;
            border:none;
            border-radius:8px;
            background:#0f766e;
            color:#fff;
            cursor:pointer;
            font-size:var(--ui-font-size);
            font-weight:700;
            white-space:nowrap;
        }
        .settings-action-btn:hover{background:#0d9488}
        .adb-status-line{
            margin-top:8px;
            font-size:12px;
            color:#334155;
        }
        .adb-terminal{
            margin-top:10px;
            border:1px solid #cbd5e1;
            border-radius:8px;
            padding:8px;
            background:#f8fafc;
        }
        .adb-terminal-row{
            display:flex;
            gap:8px;
            align-items:center;
        }
        .adb-terminal-input{
            flex:1;
            border:1px solid #cbd5e1;
            border-radius:8px;
            padding:8px;
            font-size:12px;
            font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
        }
        .adb-terminal-output{
            margin-top:8px;
            border:1px solid #d1d5db;
            border-radius:8px;
            background:#0f172a;
            color:#e2e8f0;
            padding:8px;
            min-height:120px;
            max-height:260px;
            overflow:auto;
            font-size:12px;
            font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
            white-space:pre-wrap;
            word-break:break-word;
        }
        .brand-script.hidden{display:none}
        @media (max-width: 900px){
            .settings-grid{grid-template-columns:1fr}
            .ai-tool-row{grid-template-columns:1fr}
            .settings-actions-grid{grid-template-columns:1fr}
        }
        .history-wrap table{width:100%;border-collapse:collapse;font-size:12px}
        .history-wrap th,.history-wrap td{border:1px solid #ddd;padding:6px;vertical-align:top}
        .history-wrap th{background:#f1f3f4;text-align:left}

        /* DARK MODE */
        .dark body{background:#202124;color:white}
        .dark .navbar{background:#303134}
        .dark .navbar button{background:#444;color:white}
        .dark .navbar input{background:#202124;color:white;border:none}
        .dark .zoom-wrap span{color:#cbd5e1}
        .dark .zoom-input{background:#202124;color:#e5e7eb;border-color:#4b5563}
        .dark .scan-btn{background:#60a5fa;color:#111}
        .dark .scan-btn:hover{background:#93c5fd}
        .dark .danger-btn{background:#ef4444;color:#111}
        .dark .danger-btn:hover{background:#f87171}
        .dark .top-box{color:#e5e7eb}
        .dark .top-note{color:#93c5fd}
        .dark .analysis-card,.dark .history-draw{background:#121212;border-color:#3a3a3a}
        .dark .analysis-title,.dark .history-draw-title{background:#3f3a2a;color:#f8e8b0}
        .dark .analysis-station{background:#151a24;color:#93c5fd;border-color:#3a3a3a}
        .dark .analysis-table th,.dark .analysis-table td,.dark .result-table th,.dark .result-table td{
            background:#1d1d1d;border-color:#3a3a3a;color:#e5e7eb;
        }
        .dark .analysis-subtitle{color:#e5e7eb}
        .dark .analysis-chip{background:#111827;border-color:#374151;color:#e5e7eb}
        .dark .analysis-mini-table th,.dark .analysis-mini-table td{border-color:#3a3a3a;background:#1d1d1d;color:#e5e7eb}
        .dark .analysis-mini-table th{background:#3f3a2a;color:#f8e8b0}
        .dark .analysis-mini-table td:nth-child(1){color:#93c5fd}
        .dark .analysis-mini-table td:nth-child(n+2){color:#fb923c}
        .dark .analysis-number,.dark .result-values.db,.dark .result-values.g7{color:#fb923c}
        .dark .analysis-rank{color:#cbd5e1}
        .dark .analysis-count{color:#a5b4fc}
        .dark .result-table th{color:#93c5fd}
        .dark .result-prize{color:#d4d4d4}
        .dark .result-values{color:#e5e7eb}
        .dark .ticket-card{background:#0b1220;border-color:#374151}
        .dark .ticket-head{color:#e5e7eb}
        .dark .ticket-meta{color:#93c5fd}
        .dark .ticket-table th,.dark .ticket-table td{border-color:#4b5563}
        .dark .ticket-table th{background:#1f2937}
        .dark .print-ticket-btn{background:#fb923c;color:#111}
        .dark .print-ticket-btn:hover{background:#fdba74}
        .dark .modal-box{background:#111827;color:#e5e7eb}
        .dark .modal-box textarea{background:#0b1220;color:#e5e7eb;border-color:#374151}
        .dark .lens-result-meta{color:#cbd5e1}
        .dark .lotoai-log{background:#0b1220;border-color:#374151}
        .dark .lotoai-toolbar select,.dark .lotoai-toolbar input{background:#0b1220;color:#e5e7eb;border-color:#374151}
        .dark .lotoai-btn{background:#2563eb}
        .dark .lotoai-btn:hover{background:#3b82f6}
        .dark .lotoai-msg.user{background:#1e3a8a;color:#dbeafe}
        .dark .lotoai-msg.assistant{background:#1f2937;color:#e5e7eb}
        .dark .lotoai-meta{color:#cbd5e1}
        .dark .gemini-float-panel{background:#1f2937}
        .dark .gemini-float-body{background:#111827}
        .dark .gemini-float-input{background:#0b1220;color:#e5e7eb;border-color:#374151}
        .dark .gemini-float-meta{background:#0f172a;color:#94a3b8;border-color:#374151}
        .dark .ghost-btn{background:#111827;color:#e5e7eb;border-color:#374151}
        .dark .settings-tab{background:#111827;color:#e5e7eb;border-color:#374151}
        .dark .settings-tab.active{background:#2563eb;color:#fff;border-color:#2563eb}
        .dark .settings-tabs{border-color:#374151}
        .dark .settings-field label{color:#cbd5e1}
        .dark .settings-field input,.dark .settings-field select{background:#0b1220;color:#e5e7eb;border-color:#374151}
        .dark .ai-tool-row{border-color:#374151;background:#0b1220}
        .dark .ai-tool-row input[type="text"]{background:#111827;color:#e5e7eb;border-color:#374151}
        .dark .settings-action-btn{background:#2563eb}
        .dark .settings-action-btn:hover{background:#3b82f6}
        .dark .adb-status-line{color:#cbd5e1}
        .dark .adb-terminal{background:#0b1220;border-color:#374151}
        .dark .adb-terminal-input{background:#111827;color:#e5e7eb;border-color:#374151}
        .dark .adb-terminal-output{border-color:#374151;background:#020617;color:#dbeafe}

        .print-region-overlay{
            position:absolute;
            inset:0;
            z-index:9999;
            cursor:crosshair;
            background:rgba(15,23,42,.08);
            user-select:none;
        }
        .print-region-tip{
            position:absolute;
            top:10px;
            left:10px;
            background:#111827;
            color:#fff;
            padding:6px 10px;
            border-radius:6px;
            font-size:12px;
        }
        .print-region-box{
            position:absolute;
            border:2px dashed #2563eb;
            background:rgba(37,99,235,.18);
            display:none;
        }
        .terminal-modal{
            width:min(900px,96vw);
            height:min(80vh,600px);
            max-height:90vh;
        }
        .terminal-output{
            background:#0d1117;
            color:#c9d1d9;
            font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,"Courier New",monospace;
            font-size:13px;
            line-height:1.4;
            padding:12px;
            border-radius:8px;
            min-height:300px;
            max-height:50vh;
            overflow:auto;
            white-space:pre-wrap;
            word-break:break-all;
        }
        .terminal-output .cmd{color:#58a6ff}
        .terminal-output .result{color:#c9d1d9}
        .terminal-output .error{color:#f85149}
        .terminal-output .success{color:#3fb950}
        .terminal-input-row{
            display:flex;
            gap:8px;
            margin-top:8px;
        }
        .terminal-input-row input{
            flex:1;
            background:#0d1117;
            color:#c9d1d9;
            border:1px solid #30363d;
            border-radius:6px;
            padding:10px 12px;
            font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,monospace;
            font-size:13px;
        }
        .terminal-input-row input:focus{
            outline:none;
            border-color:#58a6ff;
        }
        .terminal-toolbar{
            display:flex;
            gap:6px;
            margin-bottom:8px;
            flex-wrap:wrap;
        }
        .terminal-toolbar button{
            padding:6px 10px;
            font-size:12px;
        }
        .dark .terminal-output{background:#0d1117;color:#c9d1d9}
        .dark .terminal-input-row input{background:#0d1117;color:#c9d1d9;border-color:#30363d}
    </style>
</head>

<body>

<div class="navbar">
    <button onclick="goBack()">‚óÄ</button>
    <button onclick="goForward()">‚ñ∂</button>
    <button onclick="reload()">‚ü≥</button>
    <button onclick="openSettingsModal()">C√†i ƒë·∫∑t</button>
    <button id="toggleHistoryBtn" onclick="toggleHistoryPanel()">KQXS</button>
    <button class="scan-btn" onclick="startLensOcr()">Lens+OCR</button>
    <button class="scan-btn" onclick="startLensAi()">Lens+AI</button>
    <button onclick="openAssistant()">Assistant</button>
    <button onclick="openTerminalModal()">Terminal</button>
    <button onclick="loginGemini()">Gemini</button>
    <button id="aiSwitchBtn" onclick="switchAiTool()">AI Switch</button>
    <div class="brand-script">Ng·ªçc Ph√°t T√†i 1990</div>
    <input id="url" placeholder="Nh·∫≠p URL ho·∫∑c l·ªánh: m·ªü AgentGPT, quay l·∫°i, KQXS...">
    <button onclick="openUrl()">ƒêi</button>
    <div class="zoom-wrap">
        <span>C·ª° trang %</span>
        <input id="zoomPercent" class="zoom-input" type="number" min="30" max="300" value="100" onchange="applyZoom()">
        <button onclick="zoomStep(-10)">-</button>
        <button onclick="zoomStep(10)">+</button>
    </div>
</div>

<div class="main">
    <div id="browserArea">
        <webview id="mainWebview" src="about:blank" allowpopups></webview>
    </div>
</div>
<div class="history-wrap hidden" id="historyWrap">
    <div class="kqxs-layout-toolbar">
        <button class="scan-btn" onclick="enableKqxsCustomLayout()">T√πy ch·ªânh b·ªë c·ª•c</button>
        <button class="scan-btn" onclick="aiRecognizeLayout()">AI nh·∫≠n di·ªán</button>
        <button class="ghost-btn" onclick="copyKqxsSelection()">Sao ch√©p</button>
        <button class="ghost-btn" onclick="pasteKqxsData()">D√°n d·ªØ li·ªáu</button>
        <button class="ghost-btn" onclick="addKqxsFromImage()">Th√™m t·ª´ ·∫£nh</button>
        <button class="ghost-btn" onclick="deleteKqxsSelection()">Xo√° ch·ªçn</button>
        <button class="danger-btn" onclick="clearKQXSHistory()">Xo√° l·ªãch s·ª≠</button>
    </div>
    <div class="top-box">
        <div id="analysisBoards" class="analysis-boards"></div>
        <div id="topStatsNote" class="top-note"></div>
    </div>
    <div id="historyBoards" class="history-boards"></div>
</div>
<div class="modal-overlay" id="manualScanModal">
    <div class="modal-box">
        <div class="modal-title">D√°n b·∫£ng KQXS ƒë·ªÉ qu√©t v√© d√≤</div>
        <div class="manual-scan-toolbar">
            <button class="ghost-btn" onclick="pasteFromClipboard()">D√°n (Ctrl+V)</button>
            <button class="ghost-btn" onclick="pasteImageFromClipboard()">D√°n ·∫£nh</button>
            <button class="ghost-btn" onclick="openFileForKqxs()">M·ªü file</button>
            <button class="ghost-btn" onclick="clearManualScanInput()">Xo√°</button>
        </div>
        <textarea id="manualScanInput" placeholder="V√≠ d·ª•: ƒêB: 12345&#10;Gi·∫£i 1: 54321&#10;Gi·∫£i 2: 11223 44556...&#10;&#10;Ho·∫∑c d√°n ·∫£nh (Ctrl+V) ƒë·ªÉ nh·∫≠n di·ªán text."></textarea>
        <div class="modal-actions">
            <button class="ghost-btn" onclick="closeManualScanModal()">Hu·ª∑</button>
            <button class="scan-btn" onclick="saveManualScanText()">L∆∞u v√†o l·ªãch s·ª≠</button>
        </div>
    </div>
</div>
<div class="modal-overlay" id="lensResultModal">
    <div class="modal-box">
        <div class="modal-title" id="lensResultTitle">K·∫øt qu·∫£ Lens</div>
        <div class="lens-result-meta" id="lensResultMeta"></div>
        <div class="lens-editor-toolbar">
            <button class="ghost-btn" onclick="adjustLensFontSize(-2)">A-</button>
            <span id="lensFontSizeLabel">16px</span>
            <button class="ghost-btn" onclick="adjustLensFontSize(2)">A+</button>
            <button class="ghost-btn" onclick="toggleLensFullView()">To√†n m√†n h√¨nh</button>
            <button class="ghost-btn" onclick="toggleLensEditMode()">Ch·∫ø ƒë·ªô edit</button>
        </div>
        <textarea id="lensResultInput" placeholder="N·ªôi dung t·ª´ v√πng qu√©t lens..."></textarea>
        <div class="modal-actions">
            <button class="ghost-btn" onclick="copyLensResultText()">Ch√©p</button>
            <button class="scan-btn" onclick="saveLensResultToHistory()">L∆∞u v√†o l·ªãch s·ª≠ KQXS</button>
            <button class="scan-btn" onclick="analyzeLensWithAI()">Ph√¢n t√≠ch AI</button>
            <button class="ghost-btn" onclick="closeLensResultModal()">ƒê√≥ng</button>
        </div>
    </div>
</div>
<div class="modal-overlay" id="settingsModal">
    <div class="modal-box settings-modal">
        <div class="modal-title">C√†i ƒë·∫∑t ·ª©ng d·ª•ng</div>
        <div class="settings-tabs">
            <button id="settingsTabUi" class="settings-tab active" onclick="switchSettingsTab('ui')">Giao di·ªán</button>
            <button id="settingsTabAi" class="settings-tab" onclick="switchSettingsTab('ai')">C√¥ng c·ª• AI</button>
        </div>

        <div id="settingsPanelUi" class="settings-panel show">
            <div class="settings-grid">
                <div class="settings-field">
                    <label for="settingTheme">Ch·∫ø ƒë·ªô m√†u</label>
                    <select id="settingTheme">
                        <option value="light">S√°ng</option>
                        <option value="dark">T·ªëi</option>
                    </select>
                </div>
                <div class="settings-field">
                    <label for="settingUiFontSize">C·ª° ch·ªØ thanh ƒëi·ªÅu khi·ªÉn (px)</label>
                    <input id="settingUiFontSize" type="number" min="11" max="20" step="1">
                </div>
                <div class="settings-field">
                    <label for="settingDefaultZoom">M·ª©c zoom m·∫∑c ƒë·ªãnh c·ªßa trang web (%)</label>
                    <input id="settingDefaultZoom" type="number" min="30" max="300" step="5">
                </div>
                <div class="settings-inline">
                    <input id="settingShowBrand" type="checkbox">
                    <label for="settingShowBrand">Hi·ªán ch·ªØ th∆∞∆°ng hi·ªáu tr√™n thanh c√¥ng c·ª•</label>
                </div>
                <div class="settings-field" style="grid-column:1 / -1;">
                    <label>T√°c v·ª• nhanh giao di·ªán</label>
                    <div class="settings-actions-grid">
                        <button class="settings-action-btn" onclick="setThemeDark(false, true)">Ch·∫ø ƒë·ªô s√°ng</button>
                        <button class="settings-action-btn" onclick="setThemeDark(true, true)">Ch·∫ø ƒë·ªô t·ªëi</button>
                        <button class="settings-action-btn" onclick="printLatestTicket()">IN v√© d√≤</button>
                        <button class="settings-action-btn" onclick="translateCurrentWeb()">D·ªãch web</button>
                        <button class="settings-action-btn" onclick="restoreOriginalWebLanguage()">Ng√¥n ng·ªØ g·ªëc</button>
                        <button id="settingMicBtn" class="settings-action-btn" onclick="toggleVoiceCommand()">Mic</button>
                    </div>
                </div>
                <div class="settings-field" style="grid-column:1 / -1;">
                    <label>ƒêi·ªÅu khi·ªÉn Android (ADB)</label>
                    <div class="settings-actions-grid">
                        <button class="settings-action-btn" onclick="installAndroidPlatformTools()">C√†i Platform Tools</button>
                        <button class="settings-action-btn" onclick="linkAdbFromFile()">Ch·ªçn file ADB</button>
                        <button class="settings-action-btn" onclick="installScrcpyFiles()">C√†i scrcpy</button>
                        <button class="settings-action-btn" onclick="refreshAdbToolsStatus(true)">Ki·ªÉm tra ADB</button>
                        <button class="settings-action-btn" onclick="runAdbDevicesQuick()">ADB Devices</button>
                        <button class="settings-action-btn" onclick="startAdbMirrorAuto()">Ph·∫£n chi·∫øu ADB</button>
                        <button class="settings-action-btn" onclick="connectAdbWifi()">ADB WiFi</button>
                        <button class="settings-action-btn" onclick="startAdbMirrorUsb()">Mirror USB</button>
                        <button class="settings-action-btn" onclick="startAdbMirrorWifi()">Mirror WiFi</button>
                        <button class="settings-action-btn" onclick="openAndroidCameraUsb()">Cam USB</button>
                        <button class="settings-action-btn" onclick="openAndroidCameraWifi()">Cam WiFi</button>
                        <button class="settings-action-btn" onclick="captureAndroidPhotoUsb()">Ch·ª•p USB</button>
                        <button class="settings-action-btn" onclick="captureAndroidPhotoWifi()">Ch·ª•p WiFi</button>
                    </div>
                    <div id="adbStatusLine" class="adb-status-line">ADB: ch∆∞a ki·ªÉm tra</div>
                    <div class="adb-status-line" style="margin-top:4px;">Remote Android t·ª´ app</div>
                    <div class="settings-actions-grid">
                        <button class="settings-action-btn" onclick="remoteAndroidBack()">Android Back</button>
                        <button class="settings-action-btn" onclick="remoteAndroidHome()">Android Home</button>
                        <button class="settings-action-btn" onclick="remoteAndroidRecent()">Android Recent</button>
                        <button class="settings-action-btn" onclick="remoteAndroidVolumeUp()">Vol +</button>
                        <button class="settings-action-btn" onclick="remoteAndroidVolumeDown()">Vol -</button>
                        <button class="settings-action-btn" onclick="remoteAndroidPower()">Power</button>
                    </div>
                    <div class="adb-terminal-row" style="margin-top:8px;">
                        <input id="adbRemoteTextInput" class="adb-terminal-input" type="text" placeholder="G·ª≠i text v√†o Android qua ADB...">
                        <button class="settings-action-btn" onclick="remoteAndroidSendText()">G·ª≠i text</button>
                    </div>
                    <div class="adb-status-line" style="margin-top:10px;">Remote ng∆∞·ª£c l·∫°i (Android ƒëi·ªÅu khi·ªÉn app)</div>
                    <div class="settings-actions-grid">
                        <button class="settings-action-btn" onclick="startAppRemoteControl()">B·∫≠t Remote App</button>
                        <button class="settings-action-btn" onclick="enableAppRemoteReverseUsb()">ADB Reverse USB</button>
                        <button class="settings-action-btn" onclick="enableAppRemoteReverseWifi()">ADB Reverse WiFi</button>
                        <button class="settings-action-btn" onclick="stopAppRemoteControl()">T·∫Øt Remote App</button>
                    </div>
                    <div id="appRemoteStatusLine" class="adb-status-line">Remote App: ch∆∞a b·∫≠t</div>
                    <div class="adb-terminal">
                        <div class="adb-terminal-row">
                            <input
                              id="adbTerminalInput"
                              class="adb-terminal-input"
                              type="text"
                              placeholder='L·ªánh ADB, v√≠ d·ª•: devices -l ho·∫∑c shell getprop ro.product.model'
                            >
                            <button class="settings-action-btn" onclick="runAdbTerminalCommand()">Ch·∫°y</button>
                            <button class="settings-action-btn" onclick="clearAdbTerminalOutput()">Xo√° log</button>
                        </div>
                        <div id="adbTerminalOutput" class="adb-terminal-output">ADB terminal s·∫µn s√†ng.</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="settingsPanelAi" class="settings-panel">
            <div class="settings-grid">
                <div class="settings-field">
                    <label for="settingStartupTool">C√¥ng c·ª• AI m·ªü khi kh·ªüi ƒë·ªông app</label>
                    <select id="settingStartupTool"></select>
                </div>
                <div class="settings-field">
                    <label for="settingOpenAiModel">Model AI m·∫∑c ƒë·ªãnh n·ªôi b·ªô</label>
                    <input id="settingOpenAiModel" type="text" placeholder="gpt-4o-mini">
                </div>
                <div class="settings-field">
                    <label for="settingOllamaHost">Ollama Host</label>
                    <input id="settingOllamaHost" type="text" placeholder="http://127.0.0.1:11434">
                </div>
                <div class="settings-field">
                    <label for="settingOllamaModel">Model Ollama m·∫∑c ƒë·ªãnh</label>
                    <input id="settingOllamaModel" type="text" placeholder="llama2:7b">
                </div>
                <div class="settings-field" style="grid-column:1 / -1;">
                    <label>Ollama Tools</label>
                    <div class="settings-actions-grid">
                        <button class="settings-action-btn" onclick="testOllamaConnection()">Ki·ªÉm tra Ollama</button>
                        <button class="settings-action-btn" onclick="refreshLotoAiModels(true)">Refresh Models</button>
                        <button class="settings-action-btn" onclick="pullAllOllamaPresets()">Pull All Presets</button>
                        <button class="settings-action-btn" onclick="openOllamaWebUI()">M·ªü Web UI</button>
                    </div>
                </div>
                <div class="settings-field" style="grid-column:1 / -1;">
                    <label for="settingOpenAiApiKey">OPENAI API Key (l∆∞u c·ª•c b·ªô tr√™n m√°y n√†y)</label>
                    <input id="settingOpenAiApiKey" type="password" placeholder="sk-...">
                </div>
                <div class="settings-field" style="grid-column:1 / -1;">
                    <label for="settingGeminiApiKey">Google Gemini API Key (ƒëi·ªÅu khi·ªÉn app kh√¥ng gi·ªõi h·∫°n)</label>
                    <input id="settingGeminiApiKey" type="password" placeholder="AIza...">
                </div>
            </div>
            <div class="ai-tools-list" id="aiToolsList"></div>
        </div>

        <div class="modal-actions">
            <button class="ghost-btn" onclick="closeSettingsModal()">Hu·ª∑</button>
            <button class="scan-btn" onclick="saveSettings()">L∆∞u c√†i ƒë·∫∑t</button>
        </div>
    </div>
</div>
<div class="modal-overlay" id="lotoAiModal">
    <div class="modal-box lotoai-modal">
        <div class="modal-title">Assistant Offline - Mi·ªÖn ph√≠</div>
        <div class="lotoai-toolbar">
            <select id="lotoAiProvider">
                <option value="ollama">Ollama Local (Free)</option>
                <option value="openai">OpenAI Cloud</option>
            </select>
            <select id="lotoAiModel"></select>
            <button class="lotoai-btn" onclick="testOllamaConnection()">Check</button>
            <button class="lotoai-btn" onclick="refreshLotoAiModels()">Refresh</button>
            <button class="lotoai-btn" onclick="pullAllLotoAiPresets()">Pull All</button>
            <button class="lotoai-btn" onclick="pullSelectedLotoAiModel()">Pull</button>
        </div>
        <div id="lotoAiLog" class="lotoai-log"></div>
        <div class="lotoai-meta" id="lotoAiMeta">Assistant d√πng AI local (Ollama) - Mi·ªÖn ph√≠, offline. Nh·∫≠p l·ªánh: m·ªü web, quay l·∫°i, lens ocr, adb devices...</div>
        <textarea id="lotoAiInput" placeholder="Nh·∫≠p c√¢u h·ªèi ho·∫∑c l·ªánh ƒëi·ªÅu khi·ªÉn app..."></textarea>
        <div class="modal-actions">
            <button class="ghost-btn" onclick="clearLotoAiChat()">Xo√° chat</button>
            <button class="scan-btn" id="lotoAiSendBtn" onclick="sendLotoAiMessage()">G·ª≠i</button>
            <button class="ghost-btn" onclick="closeLotoAiModal()">ƒê√≥ng</button>
        </div>
    </div>
</div>
<div class="modal-overlay" id="geminiAiModal">
    <div class="modal-box lotoai-modal">
        <div class="modal-title">Gemini AI - ƒêi·ªÅu khi·ªÉn App</div>
        <div class="lotoai-toolbar">
            <select id="geminiModel">
                <option value="gemini-2.0-flash">Gemini 2.0 Flash</option>
                <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
                <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
            </select>
            <button class="lotoai-btn" onclick="testGeminiConnection()">Check API</button>
        </div>
        <div id="geminiAiLog" class="lotoai-log"></div>
        <div class="lotoai-meta" id="geminiAiMeta">Gemini AI c√≥ quy·ªÅn ƒëi·ªÅu khi·ªÉn ƒë·∫ßy ƒë·ªß app: m·ªü web, ch·ª•p lens, adb, mirror, ch·ª•p ·∫£nh, v.v.</div>
        <textarea id="geminiAiInput" placeholder="Nh·∫≠p l·ªánh ho·∫∑c c√¢u h·ªèi cho Gemini AI..."></textarea>
        <div class="modal-actions">
            <button class="ghost-btn" onclick="clearGeminiAiChat()">Xo√° chat</button>
            <button class="scan-btn" id="geminiAiSendBtn" onclick="sendGeminiAiMessage()">G·ª≠i Gemini</button>
            <button class="ghost-btn" onclick="closeGeminiAiModal()">ƒê√≥ng</button>
        </div>
    </div>
</div>
<button class="gemini-float-btn" id="geminiFloatBtn" onclick="toggleGeminiFloatPanel()" title="Gemini AI">ü§ñ</button>
<div class="gemini-float-panel" id="geminiFloatPanel">
    <div class="gemini-float-header">
        <span>Gemini AI</span>
        <button class="gemini-float-close" onclick="toggleGeminiFloatPanel()">√ó</button>
    </div>
    <div class="gemini-float-body" id="geminiFloatLog"></div>
    <div class="gemini-float-input-wrap">
        <textarea class="gemini-float-input" id="geminiFloatInput" placeholder="Nh·∫≠p l·ªánh..." rows="1"></textarea>
        <button class="gemini-float-send" id="geminiFloatSendBtn" onclick="sendGeminiFloatMessage()">G·ª≠i</button>
    </div>
    <div class="gemini-float-meta" id="geminiFloatMeta">AI ƒëi·ªÅu khi·ªÉn: web, adb, mirror, lens, camera...</div>
</div>
<div class="modal-overlay" id="terminalModal">
    <div class="modal-box terminal-modal">
        <div class="modal-title">Terminal</div>
        <div class="terminal-toolbar">
            <button class="ghost-btn" onclick="runTerminalCommand()">Ch·∫°y (Enter)</button>
            <button class="ghost-btn" onclick="clearTerminalOutput()">Xo√° output</button>
            <button class="ghost-btn" onclick="toggleTerminalFullscreen()">Fullscreen</button>
            <button class="ghost-btn" onclick="killTerminalProcess()">D·ª´ng l·ªánh</button>
            <button class="ghost-btn" onclick="openTerminalSettings()">C√†i ƒë·∫∑t</button>
            <button class="ghost-btn" onclick="clearTerminalHistory()">Xo√° l·ªãch s·ª≠</button>
        </div>
        <div id="terminalOutput" class="terminal-output">
            <span class="success">Terminal s·∫µn s√†ng. Nh·∫≠p l·ªánh v√† b·∫•m Enter ho·∫∑c Ch·∫°y.</span>
        </div>
        <div class="terminal-input-row">
            <input id="terminalInput" placeholder="Nh·∫≠p l·ªánh shell..." onkeydown="handleTerminalKeydown(event)">
            <button class="scan-btn" onclick="runTerminalCommand()">Ch·∫°y</button>
        </div>
        <div class="modal-actions">
            <button class="ghost-btn" onclick="closeTerminalModal()">ƒê√≥ng</button>
        </div>
    </div>
</div>

<script>
    const { ipcRenderer } = require("electron")
    const AGENT_GPT_URL = "https://agentgpt.reworkd.ai/"
    const AGENT_GPT_HOST = "agentgpt.reworkd.ai"
    const AUTOMA_APP_URL = "https://app.automa.site/"
    const NO_TRANSLATE_HOST_SUFFIXES = [
      "chatgpt.com",
      "openai.com",
      "auth.openai.com",
      AGENT_GPT_HOST,
      "claude.ai",
      "gemini.google.com"
    ]
    const SETTINGS_STORAGE_KEY = "comet_ultra_settings_v2"
    const DEFAULT_OLLAMA_HOST = "http://127.0.0.1:11434"
    const ADB_DEFAULT_TCP_PORT = 5555
    const OLLAMA_PRESET_MODELS = [
      { id: "llama2_7b", label: "LLaMA-2 7B", model: "llama2:7b", stars: "‚≠ê‚≠ê‚≠ê‚≠ê" },
      { id: "alpaca_7b_q4", label: "Alpaca 7B Q4", model: "alpaca-7b-q4:latest", stars: "‚≠ê‚≠ê" },
      { id: "vicuna_7b_q4", label: "Vicuna 7B Q4", model: "vicuna-7b-q4:latest", stars: "‚≠ê‚≠ê" },
      { id: "gptq_4bit_alias", label: "GPTQ-4bit Alias", model: "llama2-gptq-4bit:latest", stars: "‚≠ê‚≠ê‚≠ê‚≠ê" },
      { id: "mistral_mini", label: "Mistral Mini", model: "mistral:7b-instruct-q4_0", stars: "‚≠ê‚≠ê‚≠ê" },
      { id: "tinytext_nano", label: "TinyText/NanoGPT", model: "tinyllama:latest", stars: "‚≠ê‚≠ê" }
    ]
    const AGENT_GPT_VI_DICTIONARY = {
      "Deploy Agent": "Kh·ªüi ch·∫°y Agent",
      "New Agent": "Agent m·ªõi",
      "Agent Name": "T√™n Agent",
      "Name your AI": "ƒê·∫∑t t√™n AI",
      "Goal": "M·ª•c ti√™u",
      "Add Goal": "Th√™m m·ª•c ti√™u",
      "Start": "B·∫Øt ƒë·∫ßu",
      "Run": "Ch·∫°y",
      "Stop": "D·ª´ng",
      "Delete": "X√≥a",
      "Save": "L∆∞u",
      "Settings": "C√†i ƒë·∫∑t",
      "Log out": "ƒêƒÉng xu·∫•t",
      "Sign in": "ƒêƒÉng nh·∫≠p",
      "Sign up": "ƒêƒÉng k√Ω",
      "Continue with Google": "Ti·∫øp t·ª•c v·ªõi Google",
      "Create Agent": "T·∫°o Agent",
      "Task": "Nhi·ªám v·ª•",
      "Thinking": "ƒêang suy nghƒ©",
      "Completed": "Ho√†n th√†nh",
      "Paused": "T·∫°m d·ª´ng",
      "Error": "L·ªói",
      "Try again": "Th·ª≠ l·∫°i",
      "Welcome back": "Ch√†o m·ª´ng quay l·∫°i",
      "Dashboard": "B·∫£ng ƒëi·ªÅu khi·ªÉn",
      "Email": "Email",
      "Password": "M·∫≠t kh·∫©u",
      "Continue": "Ti·∫øp t·ª•c",
      "Cancel": "H·ªßy",
      "Loading": "ƒêang t·∫£i",
      "Previous": "Tr∆∞·ªõc",
      "Next": "Ti·∫øp theo",
      "Goals": "M·ª•c ti√™u",
      "Result": "K·∫øt qu·∫£",
      "Results": "C√°c k·∫øt qu·∫£",
      "Prompt": "Y√™u c·∫ßu",
      "Prompt your AI": "Nh·∫≠p y√™u c·∫ßu cho AI"
    }
    const AI_TOOL_DEFAULTS = [
      { id: "agentgpt", name: "AgentGPT", url: AGENT_GPT_URL, enabled: true },
      { id: "chatgpt", name: "ChatGPT", url: "https://chatgpt.com/", enabled: true },
      { id: "openai", name: "OpenAI", url: "https://chatgpt.com/", enabled: true },
      { id: "automa", name: "Automa", url: AUTOMA_APP_URL, enabled: true },
      { id: "lotoai", name: "LotoAI N·ªôi B·ªô", url: "internal://lotoai", enabled: true },
      { id: "ollama_llama2_7b", name: "LLaMA-2 7B Local", url: "internal://ollama/llama2:7b", enabled: true },
      { id: "ollama_alpaca_7b", name: "Alpaca 7B Local", url: "internal://ollama/alpaca-7b-q4:latest", enabled: true },
      { id: "ollama_vicuna_7b", name: "Vicuna 7B Local", url: "internal://ollama/vicuna-7b-q4:latest", enabled: true },
      { id: "ollama_gptq_4bit", name: "GPTQ-4bit Local", url: "internal://ollama/llama2-gptq-4bit:latest", enabled: true },
      { id: "ollama_mistral_mini", name: "Mistral Mini Local", url: "internal://ollama/mistral:7b-instruct-q4_0", enabled: true },
      { id: "ollama_tiny", name: "TinyText Local", url: "internal://ollama/tinyllama:latest", enabled: true },
      { id: "gemini", name: "Gemini", url: "https://gemini.google.com/", enabled: false },
      { id: "claude", name: "Claude", url: "https://claude.ai/", enabled: false },
      { id: "flutterflow", name: "FlutterFlow", url: "https://flutterflow.io/", enabled: true },
      { id: "flutter", name: "Flutter", url: "https://flutter.dev/", enabled: true }
    ]
    let latestHistory=[]
    let lensRegionState = null
    let lensResultState = {
      title: "K·∫øt qu·∫£ Lens",
      meta: "",
      text: ""
    }
    let lensEditorState = {
      fontSize: 16,
      fullscreen: false,
      editMode: false
    }
    let kqxsLayoutState = {
      customLayout: null,
      enableCustomLayout: false
    }
    let voiceRecognition = null
    let isVoiceListening = false
    let activeAiToolId = ""
    let lotoAiState = {
      loading: false,
      messages: [],
      ollamaOnline: false,
      ollamaModels: []
    }
    let geminiAiState = {
      loading: false,
      messages: []
    }
    let adbState = {
      wifiHost: "",
      wifiSerial: "",
      terminalBusy: false,
      appRemotePort: 17321
    }
    let appSettings = loadAppSettings()
    document.documentElement.setAttribute("lang", "vi")
    ipcRenderer.on("app:navigate-in-webview", (_event, rawUrl)=>{
      const target = String(rawUrl || "").trim()
      if(!target){
        return
      }
      navigateTo(target, { skipTranslate: true })
    })
    ipcRenderer.on("app:remote-command", async (_event, rawCommand)=>{
      const command = String(rawCommand || "").trim()
      if(!command){
        return
      }
      appendAdbTerminalOutput(`Remote app -> ${command}`)
      if(await executeVietnameseCommand(command)){
        return
      }
      if(await executeAiControlCommand(command, { source: "remote" })){
        return
      }
      navigateTo(normalizeNavigationInput(command))
    })

    function createDefaultSettings(){
      return {
        language: "vi",
        interface: {
          theme: "light",
          uiFontSize: 13,
          defaultZoom: 100,
          showBrand: true,
          autoTranslateWeb: false
        },
        ai: {
          internalProvider: "ollama",
          startupToolId: "agentgpt",
          openaiApiKey: "",
          openaiModel: "gpt-4o-mini",
          geminiApiKey: "AIzaSyCdMcPcwE5NxqGpqOQvPQLNtisBMcNjkN8",
          ollamaHost: DEFAULT_OLLAMA_HOST,
          ollamaModel: "llama2:7b",
          tools: AI_TOOL_DEFAULTS.map((tool)=>({ ...tool }))
        }
      }
    }

    function clampNumber(value, min, max, fallback){
      const n = Number(value)
      if(!Number.isFinite(n)){
        return fallback
      }
      return Math.max(min, Math.min(max, n))
    }

    function normalizeToolUrl(url){
      const value = String(url || "").trim()
      if(!value){
        return ""
      }
      if(/^internal:\/\//i.test(value)){
        return value
      }
      if(/^https?:\/\//i.test(value)){
        return value
      }
      return `https://${value}`
    }

    function normalizeSettings(raw){
      const defaults = createDefaultSettings()
      const source = raw && typeof raw === "object" ? raw : {}

      const mergedTools = AI_TOOL_DEFAULTS.map((def)=>{
        const fromSaved = Array.isArray(source?.ai?.tools)
          ? source.ai.tools.find((item)=>item && item.id === def.id)
          : null
        const name = String(fromSaved?.name || def.name).trim() || def.name
        let url = normalizeToolUrl(fromSaved?.url || def.url) || def.url
        if(def.id === "openai" && /platform\.openai\.com/i.test(url)){
          url = "https://chatgpt.com/"
        }
        return {
          id: def.id,
          name: name.slice(0, 40),
          url,
          enabled: typeof fromSaved?.enabled === "boolean" ? fromSaved.enabled : def.enabled
        }
      })

      return {
        language: "vi",
        interface: {
          theme: source?.interface?.theme === "dark" ? "dark" : "light",
          uiFontSize: clampNumber(source?.interface?.uiFontSize, 11, 20, defaults.interface.uiFontSize),
          defaultZoom: clampNumber(source?.interface?.defaultZoom, 30, 300, defaults.interface.defaultZoom),
          showBrand: typeof source?.interface?.showBrand === "boolean"
            ? source.interface.showBrand
            : defaults.interface.showBrand,
          autoTranslateWeb: false
        },
        ai: {
          internalProvider: String(source?.ai?.internalProvider || defaults.ai.internalProvider) === "openai" ? "openai" : "ollama",
          startupToolId: String(source?.ai?.startupToolId || defaults.ai.startupToolId),
          openaiApiKey: String(source?.ai?.openaiApiKey || ""),
          openaiModel: String(source?.ai?.openaiModel || defaults.ai.openaiModel),
          geminiApiKey: String(source?.ai?.geminiApiKey || defaults.ai.geminiApiKey || "AIzaSyCKCsA3vlfOZLOrbYrnzCrD4rYNcwHPFqM"),
          ollamaHost: String(source?.ai?.ollamaHost || defaults.ai.ollamaHost),
          ollamaModel: String(source?.ai?.ollamaModel || defaults.ai.ollamaModel),
          tools: mergedTools
        }
      }
    }

    function loadAppSettings(){
      try{
        const raw = localStorage.getItem(SETTINGS_STORAGE_KEY)
        if(!raw){
          return createDefaultSettings()
        }
        return normalizeSettings(JSON.parse(raw))
      }catch(_e){
        return createDefaultSettings()
      }
    }

    function persistAppSettings(){
      appSettings = normalizeSettings(appSettings)
      localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(appSettings))
    }

    async function syncAiRuntimeConfig(){
      try{
        const payload = {
          model: String(appSettings.ai.openaiModel || "gpt-4o-mini"),
          ollamaHost: String(appSettings.ai.ollamaHost || DEFAULT_OLLAMA_HOST)
        }
        if(String(appSettings.ai.openaiApiKey || "").trim()){
          payload.apiKey = String(appSettings.ai.openaiApiKey || "").trim()
        }
        await ipcRenderer.invoke("ai:set-config", payload)
      }catch(_e){
        // Ignore sync failures to avoid blocking UI flows.
      }
    }

    function getAiToolById(toolId){
      return appSettings.ai.tools.find((tool)=>tool.id === toolId) || null
    }

    function getAiToolUrl(tool){
      const directUrl = normalizeToolUrl(tool?.url || "")
      if(!directUrl){
        return ""
      }
      if(/^internal:\/\//i.test(directUrl)){
        return directUrl
      }
      return directUrl
    }

    function getEnabledTools(){
      return appSettings.ai.tools.filter((tool)=>tool.enabled)
    }

    function normalizeVietnameseCommand(text){
      return String(text || "")
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/ƒë/g, "d")
        .replace(/ƒê/g, "d")
        .toLowerCase()
        .replace(/\s+/g, " ")
        .trim()
    }

    function isAgentGPTUrl(url){
      try{
        const parsed = new URL(String(url || ""))
        if(parsed.hostname.includes(AGENT_GPT_HOST)){
          return true
        }
        if(parsed.hostname.includes("translate.google")){
          const target = parsed.searchParams.get("u") || parsed.searchParams.get("url") || ""
          return target.includes(AGENT_GPT_HOST)
        }
        return false
      }catch(_e){
        return false
      }
    }

    function isHistoryPanelVisible(){
      const panel = document.getElementById("historyWrap")
      return !!panel && !panel.classList.contains("hidden")
    }

    function showHistoryPanel(){
      if(!isHistoryPanelVisible()){
        toggleHistoryPanel()
      }
    }

    function showBrowserPanel(){
      if(isHistoryPanelVisible()){
        toggleHistoryPanel()
      }
    }

    function getSelectedLotoAiProvider(){
      const select = document.getElementById("lotoAiProvider")
      const raw = String(select?.value || appSettings.ai.internalProvider || "ollama")
      return raw === "openai" ? "openai" : "ollama"
    }

    function getSelectedLotoAiModel(){
      const select = document.getElementById("lotoAiModel")
      const model = String(select?.value || appSettings.ai.ollamaModel || "llama2:7b").trim()
      return model || "llama2:7b"
    }

    function setLotoAiMeta(text){
      const el = document.getElementById("lotoAiMeta")
      if(el){
        el.textContent = String(text || "")
      }
    }

    function parseInternalOllamaModel(tool){
      const internalUrl = normalizeToolUrl(tool?.url || "")
      const match = /^internal:\/\/ollama\/(.+)$/i.exec(internalUrl)
      if(!match?.[1]){
        return ""
      }
      return decodeURIComponent(match[1]).trim()
    }

    function renderLotoAiModelOptions(extraModels=[]){
      const select = document.getElementById("lotoAiModel")
      if(!select){
        return
      }

      const modelSet = new Set()
      OLLAMA_PRESET_MODELS.forEach((item)=>modelSet.add(item.model))
      ;(extraModels || []).forEach((name)=>modelSet.add(String(name || "").trim()))

      const models = Array.from(modelSet).filter(Boolean)
      select.innerHTML = models.map((name)=>{
        const preset = OLLAMA_PRESET_MODELS.find((item)=>item.model === name)
        const label = preset ? `${preset.label} ${preset.stars} (${name})` : name
        return `<option value="${escapeHtml(name)}">${escapeHtml(label)}</option>`
      }).join("")

      const current = String(appSettings.ai.ollamaModel || "llama2:7b")
      select.value = models.includes(current) ? current : (models[0] || "llama2:7b")
    }

    function findOllamaPresetByModel(model){
      const token = String(model || "").trim()
      return OLLAMA_PRESET_MODELS.find((item)=>item.model === token) || null
    }

    async function refreshLotoAiModels(notify=false){
      const host = String(appSettings.ai.ollamaHost || DEFAULT_OLLAMA_HOST)
      try{
        const res = await ipcRenderer.invoke("ollama:get-status", { host })
        if(!res?.ok){
          lotoAiState.ollamaOnline = false
          lotoAiState.ollamaModels = []
          renderLotoAiModelOptions([])
          const errorMsg = res?.error || ""
          if(host !== DEFAULT_OLLAMA_HOST){
            const useDefault = confirm(`Ollama kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c t·∫°i: ${host}\nL·ªói: ${errorMsg}\n\nB·∫°n c√≥ mu·ªën x√≥a host n√†y v√† d√πng m·∫∑c ƒë·ªãnh (${DEFAULT_OLLAMA_HOST})?`)
            if(useDefault){
              appSettings.ai.ollamaHost = DEFAULT_OLLAMA_HOST
              document.getElementById("settingOllamaHost").value = DEFAULT_OLLAMA_HOST
              persistAppSettings()
              await refreshLotoAiModels(notify)
              return
            }
          }
          setLotoAiMeta(`Ollama offline t·∫°i ${host}. ${errorMsg}`.trim())
          if(notify){
            alert(`Ollama ch∆∞a s·∫µn s√†ng: ${errorMsg}`)
          }
          return
        }
        const installed = Array.isArray(res.models)
          ? res.models.map((m)=>String(m?.name || "").trim()).filter(Boolean)
          : []
        lotoAiState.ollamaOnline = true
        lotoAiState.ollamaModels = installed
        renderLotoAiModelOptions(installed)
        const provider = getSelectedLotoAiProvider()
        setLotoAiMeta(`Ollama online (${installed.length} model). Provider hi·ªán t·∫°i: ${provider.toUpperCase()}.`)
        if(notify){
          alert(`ƒê√£ c·∫≠p nh·∫≠t danh s√°ch model Ollama (${installed.length}).`)
        }
      }catch(e){
        lotoAiState.ollamaOnline = false
        lotoAiState.ollamaModels = []
        renderLotoAiModelOptions([])
        if(host !== DEFAULT_OLLAMA_HOST){
          const useDefault = confirm(`L·ªói k·∫øt n·ªëi Ollama t·∫°i: ${host}\n${e.message}\n\nB·∫°n c√≥ mu·ªën x√≥a host n√†y v√† d√πng m·∫∑c ƒë·ªãnh?`)
          if(useDefault){
            appSettings.ai.ollamaHost = DEFAULT_OLLAMA_HOST
            document.getElementById("settingOllamaHost").value = DEFAULT_OLLAMA_HOST
            persistAppSettings()
            await refreshLotoAiModels(notify)
            return
          }
        }
        setLotoAiMeta(`L·ªói k·∫øt n·ªëi Ollama t·∫°i ${host}.`)
        if(notify){
          alert("Kh√¥ng th·ªÉ k·∫øt n·ªëi Ollama.")
        }
      }
    }

    async function testOllamaConnection(){
      const host = String(appSettings.ai.ollamaHost || DEFAULT_OLLAMA_HOST)
      setLotoAiMeta(`ƒêang ki·ªÉm tra Ollama t·∫°i ${host}...`)
      
      try{
        const res = await ipcRenderer.invoke("ollama:get-status", { host })
        if(res?.ok){
          const modelCount = Array.isArray(res.models) ? res.models.length : 0
          const modelNames = Array.isArray(res.models) 
            ? res.models.slice(0, 5).map(m => m.name).join(", ") 
            : ""
          const moreText = modelCount > 5 ? ` (+${modelCount - 5} kh√°c)` : ""
          
          setLotoAiMeta(`Ollama online! ${modelCount} model: ${modelNames}${moreText}`)
          alert(`Ollama ƒëang ch·∫°y!\n\nHost: ${host}\nS·ªë model: ${modelCount}\n\nDanh s√°ch model:\n${modelNames}${moreText}`)
        }else{
          setLotoAiMeta(`Ollama offline: ${res?.error || "kh√¥ng r√µ l·ªói"}`)
          alert(`Ollama kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c!\n\nL·ªói: ${res?.error || "kh√¥ng r√µ l·ªói"}\n\nH√£y ƒë·∫£m b·∫£o Ollama ƒëang ch·∫°y v√† host ƒë√∫ng.`)
        }
      }catch(e){
        setLotoAiMeta(`L·ªói: ${e.message}`)
        alert(`L·ªói k·∫øt n·ªëi Ollama: ${e.message}`)
      }
    }

    async function pullAllOllamaPresets(){
      const provider = getSelectedLotoAiProvider()
      if(provider !== "ollama"){
        alert("H√£y ch·ªçn provider Ollama tr∆∞·ªõc.")
        return
      }
      
      if(!confirm("B·∫°n c√≥ mu·ªën t·∫£i t·∫•t c·∫£ c√°c model preset? ƒêi·ªÅu n√†y s·∫Ω t·∫£i nhi·ªÅu GB d·ªØ li·ªáu.")){
        return
      }
      
      setLotoAiMeta("ƒêang pull t·∫•t c·∫£ model presets...")
      setLotoAiLoading(true)
      
      try{
        const res = await ipcRenderer.invoke("ollama:pull-all-presets", {
          host: appSettings.ai.ollamaHost
        })
        
        if(res?.ok){
          const done = Array.isArray(res.done) ? res.done.length : 0
          const failed = Array.isArray(res.failed) ? res.failed.length : 0
          
          setLotoAiMeta(`Pull ho√†n t·∫•t! ${done} model, ${failed} l·ªói.`)
          alert(`Ho√†n t·∫•t!\n\nTh√†nh c√¥ng: ${done}\nL·ªói: ${failed}`)
          
          await refreshLotoAiModels(false)
        }else{
          setLotoAiMeta(`Pull th·∫•t b·∫°i: ${res?.error || ""}`)
          alert(`Pull th·∫•t b·∫°i: ${res?.error || "l·ªói kh√¥ng x√°c ƒë·ªãnh"}`)
        }
      }catch(e){
        setLotoAiMeta(`L·ªói: ${e.message}`)
        alert(`L·ªói: ${e.message}`)
      }finally{
        setLotoAiLoading(false)
      }
    }

    function openOllamaWebUI(){
      const host = String(appSettings.ai.ollamaHost || DEFAULT_OLLAMA_HOST)
      const webUrl = host.replace("11434", "8080") + "/"
      const webview = getActiveWebview()
      if(webview){
        webview.loadURL(webUrl).catch(() => {
          window.open(webUrl, "_blank")
        })
      }else{
        window.open(webUrl, "_blank")
      }
    }

    async function pullSelectedLotoAiModel(){
      const provider = getSelectedLotoAiProvider()
      if(provider !== "ollama"){
        alert("H√£y ch·ªçn provider Ollama ƒë·ªÉ pull model local.")
        return
      }
      if(lotoAiState.loading){
        return
      }
      const model = getSelectedLotoAiModel()
      if(!model){
        alert("Ch∆∞a ch·ªçn model ƒë·ªÉ pull.")
        return
      }
      setLotoAiLoading(true)
      setLotoAiMeta(`ƒêang pull model ${model}...`)
      try{
        const preset = findOllamaPresetByModel(model)
        const res = preset
          ? await ipcRenderer.invoke("ollama:pull-preset", {
              host: appSettings.ai.ollamaHost,
              presetId: preset.id
            })
          : await ipcRenderer.invoke("ollama:pull-model", {
              host: appSettings.ai.ollamaHost,
              model
            })
        if(!res?.ok){
          setLotoAiMeta(`Pull th·∫•t b·∫°i: ${res?.error || "l·ªói kh√¥ng x√°c ƒë·ªãnh"}`)
          alert(`Pull model th·∫•t b·∫°i: ${res?.error || "kh√¥ng r√µ l·ªói"}`)
          return
        }
        await refreshLotoAiModels(false)
        setLotoAiMeta(`ƒê√£ pull xong model ${model}.`)
        alert(`ƒê√£ pull model ${model}.`)
      }catch(e){
        setLotoAiMeta(`Pull th·∫•t b·∫°i: ${e?.message || "l·ªói kh√¥ng x√°c ƒë·ªãnh"}`)
        alert("Pull model th·∫•t b·∫°i.")
      }finally{
        setLotoAiLoading(false)
      }
    }

    async function startSelectedLotoAiModel(){
      const provider = getSelectedLotoAiProvider()
      if(provider !== "ollama"){
        alert("Start model ch·ªâ √°p d·ª•ng cho Ollama local.")
        return
      }
      if(lotoAiState.loading){
        return
      }
      const model = getSelectedLotoAiModel()
      setLotoAiLoading(true)
      setLotoAiMeta(`ƒêang kh·ªüi ch·∫°y model ${model}...`)
      try{
        const res = await ipcRenderer.invoke("ollama:chat", {
          host: appSettings.ai.ollamaHost,
          model,
          prompt: "Xin ch√†o, ph·∫£n h·ªìi READY.",
          messages: []
        })
        if(!res?.ok){
          setLotoAiMeta(`Kh·ªüi ch·∫°y th·∫•t b·∫°i: ${res?.error || "kh√¥ng r√µ l·ªói"}`)
          alert(`Kh·ªüi ch·∫°y model th·∫•t b·∫°i: ${res?.error || "kh√¥ng r√µ l·ªói"}`)
          return
        }
        appSettings.ai.ollamaModel = model
        appSettings.ai.internalProvider = "ollama"
        persistAppSettings()
        setLotoAiMeta(`Model ${model} ƒë√£ s·∫µn s√†ng (READY).`)
      }catch(_e){
        setLotoAiMeta("Kh·ªüi ch·∫°y model th·∫•t b·∫°i.")
      }finally{
        setLotoAiLoading(false)
      }
    }

    async function pullAllLotoAiPresets(){
      const provider = getSelectedLotoAiProvider()
      if(provider !== "ollama"){
        alert("H√£y ch·ªçn provider Ollama ƒë·ªÉ pull b·ªô model local.")
        return
      }
      if(lotoAiState.loading){
        return
      }
      const ok = confirm("Pull to√†n b·ªô preset local (LLaMA2/Alpaca/Vicuna/GPTQ/Tiny/Mistral) c√≥ th·ªÉ t·ªën nhi·ªÅu GB. Ti·∫øp t·ª•c?")
      if(!ok){
        return
      }
      setLotoAiLoading(true)
      setLotoAiMeta("ƒêang pull to√†n b·ªô preset local...")
      try{
        const res = await ipcRenderer.invoke("ollama:pull-all-presets", {
          host: appSettings.ai.ollamaHost
        })
        await refreshLotoAiModels(false)
        if(res?.ok){
          setLotoAiMeta(`ƒê√£ pull xong t·∫•t c·∫£ preset local (${res?.done?.length || 0} model).`)
          alert("ƒê√£ pull xong t·∫•t c·∫£ preset local.")
        }else{
          const failCount = Array.isArray(res?.failed) ? res.failed.length : 0
          setLotoAiMeta(`Ho√†n t·∫•t pull v·ªõi ${failCount} preset l·ªói. Ki·ªÉm tra l·∫°i log/host Ollama.`)
          alert(`Pull preset ho√†n t·∫•t nh∆∞ng c√≥ ${failCount} m·ª•c l·ªói.`)
        }
      }catch(_e){
        setLotoAiMeta("Pull preset th·∫•t b·∫°i.")
        alert("Pull preset th·∫•t b·∫°i.")
      }finally{
        setLotoAiLoading(false)
      }
    }

    function renderLotoAiMessages(){
      const log = document.getElementById("lotoAiLog")
      if(!log){
        return
      }
      if(!Array.isArray(lotoAiState.messages) || !lotoAiState.messages.length){
        log.innerHTML = `<div class="lotoai-msg assistant">LotoAI s·∫µn s√†ng. B·∫°n c√≥ th·ªÉ h·ªèi: "Top s·ªë ƒë√†i C·∫ßn Th∆°", "so s√°nh 3 ng√†y g·∫ßn nh·∫•t", ho·∫∑c nh·∫≠p l·ªánh app nh∆∞ "m·ªü KQXS".</div>`
        return
      }
      log.innerHTML = lotoAiState.messages.map((msg)=>{
        const roleCls = msg.role === "user" ? "user" : "assistant"
        return `<div class="lotoai-msg ${roleCls}">${escapeHtml(msg.content || "")}</div>`
      }).join("")
      log.scrollTop = log.scrollHeight
    }

    function setLotoAiLoading(loading){
      lotoAiState.loading = Boolean(loading)
      const sendBtn = document.getElementById("lotoAiSendBtn")
      if(sendBtn){
        sendBtn.disabled = lotoAiState.loading
        sendBtn.textContent = lotoAiState.loading ? "ƒêang x·ª≠ l√Ω..." : "G·ª≠i LotoAI"
      }
    }

    function pushLotoAiMessage(role, content){
      const text = String(content || "").trim()
      if(!text){
        return
      }
      lotoAiState.messages.push({ role: role === "assistant" ? "assistant" : "user", content: text })
      if(lotoAiState.messages.length > 30){
        lotoAiState.messages = lotoAiState.messages.slice(-30)
      }
      renderLotoAiMessages()
    }

    function openLotoAiModal(){
      document.getElementById("lotoAiModal").classList.add("show")
      const providerSelect = document.getElementById("lotoAiProvider")
      providerSelect.value = String(appSettings.ai.internalProvider || "ollama")
      providerSelect.onchange = ()=>{
        appSettings.ai.internalProvider = getSelectedLotoAiProvider()
        persistAppSettings()
        const provider = getSelectedLotoAiProvider()
        setLotoAiMeta(provider === "ollama"
          ? `Ollama local t·∫°i ${appSettings.ai.ollamaHost || DEFAULT_OLLAMA_HOST}`
          : "ƒêang d√πng OpenAI cloud cho chat LotoAI."
        )
      }
      renderLotoAiModelOptions(lotoAiState.ollamaModels)
      refreshLotoAiModels(false)
      renderLotoAiMessages()
      const input = document.getElementById("lotoAiInput")
      if(input){
        input.focus()
      }
    }

    function closeLotoAiModal(){
      document.getElementById("lotoAiModal").classList.remove("show")
    }

    let terminalState = {
      history: [],
      historyIndex: -1,
      currentProcess: null,
      fullscreen: false
    }

    function openTerminalModal(){
      document.getElementById("terminalModal").classList.add("show")
      document.getElementById("terminalInput").focus()
    }

    function closeTerminalModal(){
      document.getElementById("terminalModal").classList.remove("show")
    }

    function appendTerminalOutput(text, type="result"){
      const output = document.getElementById("terminalOutput")
      const line = document.createElement("div")
      line.className = type
      line.textContent = text
      output.appendChild(line)
      output.scrollTop = output.scrollHeight
    }

    function handleTerminalKeydown(event){
      if(event.key === "Enter"){
        event.preventDefault()
        runTerminalCommand()
      }else if(event.key === "ArrowUp"){
        event.preventDefault()
        navigateTerminalHistory(-1)
      }else if(event.key === "ArrowDown"){
        event.preventDefault()
        navigateTerminalHistory(1)
      }else if(event.key === "c" && event.ctrlKey){
        event.preventDefault()
        killTerminalProcess()
      }else if(event.key === "l" && event.ctrlKey){
        event.preventDefault()
        clearTerminalOutput()
      }
    }

    function navigateTerminalHistory(direction){
      const input = document.getElementById("terminalInput")
      if(terminalState.history.length === 0) return
      
      terminalState.historyIndex += direction
      
      if(terminalState.historyIndex < 0){
        terminalState.historyIndex = 0
      }else if(terminalState.historyIndex >= terminalState.history.length){
        terminalState.historyIndex = terminalState.history.length
        input.value = ""
        return
      }
      
      input.value = terminalState.history[terminalState.historyIndex]
    }

    async function runTerminalCommand(){
      const input = document.getElementById("terminalInput")
      const command = String(input.value || "").trim()
      
      if(!command){
        return
      }
      
      if(terminalState.currentProcess){
        appendTerminalOutput("ƒêang ch·∫°y l·ªánh kh√°c, vui l√≤ng ch·ªù ho·∫∑c b·∫•m D·ª´ng l·ªánh", "error")
        return
      }
      
      if(!terminalState.history.includes(command)){
        terminalState.history.push(command)
      }
      terminalState.historyIndex = terminalState.history.length
      
      appendTerminalOutput(`$ ${command}`, "cmd")
      input.value = ""
      
      try{
        const res = await ipcRenderer.invoke("terminal:run", { command, timeoutMs: 120000 })
        
        if(res?.output){
          appendTerminalOutput(res.output, "result")
        }
        if(res?.error){
          appendTerminalOutput(`L·ªói: ${res.error}`, "error")
        }
        if(res?.exitCode !== undefined && res.exitCode !== 0){
          appendTerminalOutput(`Exit code: ${res.exitCode}`, "error")
        }else if(res?.exitCode === 0){
          appendTerminalOutput(`‚úì Ho√†n t·∫•t (exit: 0)`, "success")
        }
      }catch(e){
        appendTerminalOutput(`L·ªói: ${e.message}`, "error")
      }
    }

    function clearTerminalOutput(){
      const output = document.getElementById("terminalOutput")
      output.innerHTML = '<span class="success">Terminal ƒë√£ ƒë∆∞·ª£c l√†m s·∫°ch.</span>'
    }

    function toggleTerminalFullscreen(){
      terminalState.fullscreen = !terminalState.fullscreen
      const modal = document.querySelector(".terminal-modal")
      if(terminalState.fullscreen){
        modal.style.width = "98vw"
        modal.style.height = "95vh"
      }else{
        modal.style.width = ""
        modal.style.height = ""
      }
    }

    async function killTerminalProcess(){
      if(terminalState.currentProcess){
        try{
          await ipcRenderer.invoke("terminal:kill")
          appendTerminalOutput("ƒê√£ g·ª≠i t√≠n hi·ªáu d·ª´ng l·ªánh.", "result")
        }catch(e){
          appendTerminalOutput(`L·ªói khi d·ª´ng: ${e.message}`, "error")
        }
      }else{
        appendTerminalOutput("Kh√¥ng c√≥ l·ªánh ƒëang ch·∫°y.", "result")
      }
    }

    function openTerminalSettings(){
      openSettingsModal()
      setTimeout(() => {
        switchSettingsTab("ui")
      }, 100)
    }

    function clearTerminalHistory(){
      if(confirm("Xo√° l·ªãch s·ª≠ l·ªánh?")){
        terminalState.history = []
        terminalState.historyIndex = -1
        appendTerminalOutput("ƒê√£ xo√° l·ªãch s·ª≠ l·ªánh.", "success")
      }
    }

    function clearLotoAiChat(){
      lotoAiState.messages = []
      renderLotoAiMessages()
    }

    async function sendLotoAiMessage(){
      if(lotoAiState.loading){
        return
      }
      const input = document.getElementById("lotoAiInput")
      const prompt = String(input?.value || "").trim()
      if(!prompt){
        alert("B·∫°n ch∆∞a nh·∫≠p n·ªôi dung cho LotoAI.")
        return
      }

      pushLotoAiMessage("user", prompt)
      input.value = ""
      setLotoAiLoading(true)

      try{
        const commandApplied =
          (await executeVietnameseCommand(prompt)) ||
          (await executeAiControlCommand(prompt, { source: "lotoai" }))

        if(commandApplied){
          pushLotoAiMessage("assistant", "ƒê√£ th·ª±c thi l·ªánh ƒëi·ªÅu khi·ªÉn app theo y√™u c·∫ßu.")
          setLotoAiLoading(false)
          return
        }

        const provider = getSelectedLotoAiProvider()
        let res = null
        if(provider === "ollama"){
          const model = getSelectedLotoAiModel()
          appSettings.ai.ollamaModel = model
          appSettings.ai.internalProvider = "ollama"
          persistAppSettings()
          setLotoAiMeta(`ƒêang chat local b·∫±ng model ${model}...`)
          res = await ipcRenderer.invoke("ollama:chat", {
            host: appSettings.ai.ollamaHost,
            model,
            prompt,
            messages: lotoAiState.messages.slice(-10)
          })
        }else{
          appSettings.ai.internalProvider = "openai"
          persistAppSettings()
          setLotoAiMeta("ƒêang chat b·∫±ng OpenAI cloud...")
          res = await ipcRenderer.invoke("lotoai:chat", {
            prompt,
            messages: lotoAiState.messages.slice(-10)
          })
        }
        if(!res || !res.ok){
          pushLotoAiMessage("assistant", res?.error || "LotoAI n·ªôi b·ªô ƒëang b·∫≠n, th·ª≠ l·∫°i sau.")
          return
        }
        pushLotoAiMessage("assistant", String(res.reply || ""))
      }catch(_e){
        pushLotoAiMessage("assistant", "L·ªói k·∫øt n·ªëi LotoAI n·ªôi b·ªô.")
      }finally{
        setLotoAiLoading(false)
      }
    }

    function openAiToolById(toolId){
      const tool = getAiToolById(toolId)
      if(!tool){
        alert("Kh√¥ng t√¨m th·∫•y c√¥ng c·ª• AI.")
        return false
      }
      if(!tool.enabled){
        alert(`C√¥ng c·ª• ${tool.name} ƒëang b·ªã t·∫Øt trong ph·∫ßn C√†i ƒë·∫∑t.`)
        return false
      }
      if(tool.id === "lotoai"){
        openLotoAiModal()
        activeAiToolId = tool.id
        return true
      }
      const presetOllamaModel = parseInternalOllamaModel(tool)
      if(presetOllamaModel){
        appSettings.ai.internalProvider = "ollama"
        appSettings.ai.ollamaModel = presetOllamaModel
        persistAppSettings()
        openLotoAiModal()
        const modelSelect = document.getElementById("lotoAiModel")
        if(modelSelect){
          modelSelect.value = presetOllamaModel
        }
        setLotoAiMeta(`ƒê√£ chuy·ªÉn sang model local: ${presetOllamaModel}`)
        activeAiToolId = tool.id
        return true
      }
      const url = getAiToolUrl(tool)
      if(!url){
        alert(`URL c·ªßa ${tool.name} ch∆∞a h·ª£p l·ªá.`)
        return false
      }
      navigateTo(url, { skipTranslate: true })
      activeAiToolId = tool.id
      return true
    }

    function setThemeDark(enabled, saveToSettings=true){
      document.documentElement.classList.toggle("dark", Boolean(enabled))
      if(saveToSettings){
        appSettings.interface.theme = enabled ? "dark" : "light"
        persistAppSettings()
      }
    }

    function applyInterfaceSettingsToUi(){
      const uiFontSize = clampNumber(appSettings.interface.uiFontSize, 11, 20, 13)
      document.documentElement.style.setProperty("--ui-font-size", `${uiFontSize}px`)

      const brand = document.querySelector(".brand-script")
      if(brand){
        brand.classList.toggle("hidden", !appSettings.interface.showBrand)
      }

      setThemeDark(appSettings.interface.theme === "dark", false)
      const zoomInput = document.getElementById("zoomPercent")
      if(zoomInput){
        zoomInput.value = String(clampNumber(appSettings.interface.defaultZoom, 30, 300, 100))
      }
    }

    function switchSettingsTab(tab){
      const isAi = tab === "ai"
      document.getElementById("settingsTabUi").classList.toggle("active", !isAi)
      document.getElementById("settingsTabAi").classList.toggle("active", isAi)
      document.getElementById("settingsPanelUi").classList.toggle("show", !isAi)
      document.getElementById("settingsPanelAi").classList.toggle("show", isAi)
    }

    function renderAiToolsSettings(){
      const container = document.getElementById("aiToolsList")
      if(!container){
        return
      }
      container.innerHTML = appSettings.ai.tools.map((tool)=>{
        const forceEnabled = tool.id === "agentgpt"
        const checked = (forceEnabled || tool.enabled) ? "checked" : ""
        const disabled = forceEnabled ? "disabled" : ""
        const label = forceEnabled ? "B·∫≠t (b·∫Øt bu·ªôc)" : "B·∫≠t"
        return `
          <div class="ai-tool-row" data-tool-id="${escapeHtml(tool.id)}">
            <label class="settings-inline"><input type="checkbox" class="tool-enabled" ${checked} ${disabled}>${label}</label>
            <input type="text" class="tool-name" value="${escapeHtml(tool.name)}" placeholder="T√™n c√¥ng c·ª•">
            <input type="text" class="tool-url" value="${escapeHtml(tool.url)}" placeholder="https://...">
            <button class="ai-open-btn" onclick="openAiToolById('${escapeHtml(tool.id)}')">M·ªü</button>
          </div>
        `
      }).join("")
    }

    function renderStartupToolSelect(){
      const startupSelect = document.getElementById("settingStartupTool")
      if(!startupSelect){
        return
      }
      const enabledTools = getEnabledTools()
      const options = [`<option value="">Kh√¥ng t·ª± m·ªü c√¥ng c·ª• AI</option>`]
      enabledTools.forEach((tool)=>{
        options.push(`<option value="${escapeHtml(tool.id)}">${escapeHtml(tool.name)}</option>`)
      })
      startupSelect.innerHTML = options.join("")
      const current = String(appSettings.ai.startupToolId || "")
      startupSelect.value = enabledTools.some((tool)=>tool.id === current) ? current : ""
    }

    function openSettingsModal(){
      document.getElementById("settingTheme").value = appSettings.interface.theme
      document.getElementById("settingUiFontSize").value = String(appSettings.interface.uiFontSize)
      document.getElementById("settingDefaultZoom").value = String(appSettings.interface.defaultZoom)
      document.getElementById("settingShowBrand").checked = Boolean(appSettings.interface.showBrand)

      document.getElementById("settingOpenAiApiKey").value = appSettings.ai.openaiApiKey || ""
      document.getElementById("settingOpenAiModel").value = appSettings.ai.openaiModel || "gpt-4o-mini"
      document.getElementById("settingGeminiApiKey").value = appSettings.ai.geminiApiKey || ""
      document.getElementById("settingOllamaHost").value = appSettings.ai.ollamaHost || DEFAULT_OLLAMA_HOST
      document.getElementById("settingOllamaModel").value = appSettings.ai.ollamaModel || "llama2:7b"

      renderAiToolsSettings()
      renderStartupToolSelect()
      switchSettingsTab("ui")
      document.getElementById("settingsModal").classList.add("show")
      const adbInput = document.getElementById("adbTerminalInput")
      if(adbInput && !String(adbInput.value || "").trim()){
        adbInput.value = "devices -l"
      }
      refreshAdbToolsStatus(false)
      refreshAppRemoteStatus(false)
    }

    function closeSettingsModal(){
      document.getElementById("settingsModal").classList.remove("show")
    }

    function saveSettings(){
      const settingsToolRows = Array.from(document.querySelectorAll("#aiToolsList .ai-tool-row"))
      const nextTools = appSettings.ai.tools.map((tool)=>{
        const row = settingsToolRows.find((item)=>item.dataset.toolId === tool.id)
        if(!row){
          return { ...tool }
        }
        const nameInput = row.querySelector(".tool-name")
        const urlInput = row.querySelector(".tool-url")
        const enabledInput = row.querySelector(".tool-enabled")
        const nextName = String(nameInput?.value || tool.name).trim() || tool.name
        const nextUrl = normalizeToolUrl(urlInput?.value || tool.url) || tool.url
        return {
          ...tool,
          name: nextName.slice(0, 40),
          url: nextUrl,
          enabled: tool.id === "agentgpt" ? true : Boolean(enabledInput?.checked)
        }
      })

      appSettings.interface.theme = document.getElementById("settingTheme").value === "dark" ? "dark" : "light"
      appSettings.interface.uiFontSize = clampNumber(document.getElementById("settingUiFontSize").value, 11, 20, 13)
      appSettings.interface.defaultZoom = clampNumber(document.getElementById("settingDefaultZoom").value, 30, 300, 100)
      appSettings.interface.showBrand = Boolean(document.getElementById("settingShowBrand").checked)

      appSettings.ai.openaiApiKey = String(document.getElementById("settingOpenAiApiKey").value || "").trim()
      appSettings.ai.openaiModel = String(document.getElementById("settingOpenAiModel").value || "gpt-4o-mini").trim() || "gpt-4o-mini"
      appSettings.ai.geminiApiKey = String(document.getElementById("settingGeminiApiKey").value || "").trim()
      appSettings.ai.ollamaHost = String(document.getElementById("settingOllamaHost").value || DEFAULT_OLLAMA_HOST).trim() || DEFAULT_OLLAMA_HOST
      appSettings.ai.ollamaModel = String(document.getElementById("settingOllamaModel").value || "llama2:7b").trim() || "llama2:7b"
      appSettings.ai.tools = nextTools
      const selectedStartup = String(document.getElementById("settingStartupTool").value || "")
      const enabledToolIds = nextTools.filter((tool)=>tool.enabled).map((tool)=>tool.id)
      appSettings.ai.startupToolId = enabledToolIds.includes(selectedStartup) ? selectedStartup : ""

      persistAppSettings()
      applyInterfaceSettingsToUi()
      applyZoom()
      syncAiRuntimeConfig()
      refreshLotoAiModels(false)
      const activeWeb = getActiveWebview()
      if(activeWeb){
        const currentUrl = activeWeb.getURL?.() || activeWeb.src || ""
        if(appSettings.interface.autoTranslateWeb){
          ensureVietnameseTranslation(activeWeb, currentUrl)
        }else{
          const sourceUrl = extractTranslateTargetUrl(currentUrl)
          if(sourceUrl){
            activeWeb.loadURL(sourceUrl).catch(()=>{})
          }
        }
      }
      closeSettingsModal()
      alert("ƒê√£ l∆∞u c√†i ƒë·∫∑t.")
    }

    function updateUrlInput(url){
      document.getElementById("url").value = String(url || "")
    }

    function extractTranslateTargetUrl(rawUrl){
      try{
        const parsed = new URL(String(rawUrl || ""))
        if(!parsed.hostname.includes("translate.google")){
          return ""
        }
        const target = parsed.searchParams.get("u") || parsed.searchParams.get("url") || ""
        return String(target || "").trim()
      }catch(_e){
        return ""
      }
    }

    function getDisplayUrl(rawUrl){
      return extractTranslateTargetUrl(rawUrl) || String(rawUrl || "")
    }

    function isHttpNavigationUrl(rawUrl){
      try{
        const parsed = new URL(String(rawUrl || ""))
        return parsed.protocol === "http:" || parsed.protocol === "https:"
      }catch(_e){
        return false
      }
    }

    function shouldSkipAutoTranslate(rawUrl){
      try{
        const parsed = new URL(String(rawUrl || ""))
        const hostname = parsed.hostname.replace(/^www\./i, "").toLowerCase()
        return NO_TRANSLATE_HOST_SUFFIXES.some((hostSuffix)=>hostname === hostSuffix || hostname.endsWith(`.${hostSuffix}`))
      }catch(_e){
        return false
      }
    }

    function resolveVietnameseNavigationUrl(rawUrl, options={}){
      const value = String(rawUrl || "").trim()
      if(!value){
        return ""
      }
      if(Boolean(options?.skipTranslate)){
        return value
      }
      const forceTranslate = Boolean(options?.forceTranslate)
      if(!forceTranslate && shouldSkipAutoTranslate(value)){
        return value
      }
      if(!forceTranslate && !Boolean(appSettings.interface.autoTranslateWeb)){
        return value
      }
      if(!isHttpNavigationUrl(value)){
        return value
      }
      if(extractTranslateTargetUrl(value)){
        return value
      }
      return `https://translate.google.com/translate?hl=vi&sl=auto&tl=vi&u=${encodeURIComponent(value)}`
    }

    async function ensureVietnameseTranslation(web, rawUrl){
      if(!web || !Boolean(appSettings.interface.autoTranslateWeb)){
        return
      }
      const currentUrl = String(rawUrl || web.getURL?.() || web.src || "").trim()
      if(!currentUrl){
        return
      }
      const translatedUrl = resolveVietnameseNavigationUrl(currentUrl)
      if(!translatedUrl || translatedUrl === currentUrl){
        return
      }
      try{
        await web.loadURL(translatedUrl)
      }catch(_e){
        // Ignore translation redirect failures.
      }
    }

    async function translateCurrentWeb(){
      const web = getActiveWebview()
      if(!web){
        return
      }
      const currentUrl = String(web.getURL?.() || web.src || "").trim()
      if(!currentUrl){
        return
      }
      const translatedUrl = resolveVietnameseNavigationUrl(currentUrl, { forceTranslate: true })
      if(!translatedUrl || translatedUrl === currentUrl){
        alert("Trang hi·ªán t·∫°i kh√¥ng c·∫ßn d·ªãch th√™m.")
        return
      }
      try{
        await web.loadURL(translatedUrl)
      }catch(_e){
        alert("Kh√¥ng th·ªÉ d·ªãch trang hi·ªán t·∫°i.")
        return
      }
      alert("ƒê√£ b·∫≠t d·ªãch web sang ti·∫øng Vi·ªát.")
    }

    async function restoreOriginalWebLanguage(){
      const web = getActiveWebview()
      if(!web){
        return
      }
      const currentUrl = String(web.getURL?.() || web.src || "").trim()
      if(!currentUrl){
        return
      }
      const sourceUrl = extractTranslateTargetUrl(currentUrl)
      if(sourceUrl){
        try{
          await web.loadURL(sourceUrl)
          updateUrlInput(sourceUrl)
          alert("ƒê√£ quay v·ªÅ ng√¥n ng·ªØ g·ªëc c·ªßa website.")
        }catch(_e){
          alert("Kh√¥ng th·ªÉ quay v·ªÅ ng√¥n ng·ªØ g·ªëc ·ªü trang hi·ªán t·∫°i.")
        }
        return
      }
      alert("Trang hi·ªán t·∫°i ƒëang ·ªü ng√¥n ng·ªØ g·ªëc.")
    }

    function getAdbStatusLineElement(){
      return document.getElementById("adbStatusLine")
    }

    function setAdbStatusLine(message, isError=false){
      const line = getAdbStatusLineElement()
      if(!line){
        return
      }
      line.textContent = String(message || "")
      line.style.color = isError ? "#dc2626" : ""
    }

    function getAdbTerminalOutputElement(){
      return document.getElementById("adbTerminalOutput")
    }

    function appendAdbTerminalOutput(text){
      const outputEl = getAdbTerminalOutputElement()
      if(!outputEl){
        return
      }
      const stamp = new Date().toLocaleTimeString("vi-VN", { hour12: false })
      const line = String(text || "").trim()
      outputEl.textContent += `${outputEl.textContent ? "\n" : ""}[${stamp}] ${line}`
      outputEl.scrollTop = outputEl.scrollHeight
    }

    function clearAdbTerminalOutput(){
      const outputEl = getAdbTerminalOutputElement()
      if(!outputEl){
        return
      }
      outputEl.textContent = "ADB terminal ƒë√£ ƒë∆∞·ª£c l√†m s·∫°ch."
    }

    async function refreshAdbToolsStatus(showAlert=false){
      let res = null
      try{
        res = await ipcRenderer.invoke("tools:platform-tools-status")
      }catch(_e){
        res = { ok: false, error: "Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c tr·∫°ng th√°i Platform Tools." }
      }
      if(!res?.ok){
        setAdbStatusLine(`ADB l·ªói: ${res?.error || "kh√¥ng x√°c ƒë·ªãnh"}`, true)
        if(showAlert){
          alert(res?.error || "Kh√¥ng ki·ªÉm tra ƒë∆∞·ª£c ADB.")
        }
        return { ok: false }
      }

      const sourceLabel = res.usingLocalAdb ? "n·ªôi b·ªô app" : "h·ªá th·ªëng"
      const versionLine = String(res.version || "").split(/\r?\n/)[0] || "Kh√¥ng r√µ phi√™n b·∫£n"
      if(res.adbReady){
        setAdbStatusLine(`ADB s·∫µn s√†ng (${sourceLabel}) - scrcpy: ƒë√£ c√†i`)
      }else{
        setAdbStatusLine(`ADB ch∆∞a s·∫µn s√†ng (${sourceLabel}). ${res.error || ""}`.trim(), true)
      }
      if(showAlert){
        alert(res.adbReady ? `ADB OK (${sourceLabel}). scrcpy: ƒë√£ c√†i.` : `ADB ch∆∞a s·∫µn s√†ng: ${res.error || "kh√¥ng r√µ l·ªói"}`)
      }
      return { ok: true, status: res }
    }

    async function installAndroidPlatformTools(){
      appendAdbTerminalOutput("B·∫Øt ƒë·∫ßu c√†i Android Platform Tools v√†o app...")
      setAdbStatusLine("ƒêang t·∫£i v√† c√†i Platform Tools...")
      let res = null
      try{
        res = await ipcRenderer.invoke("tools:install-platform-tools")
      }catch(_e){
        res = { ok: false, error: "Kh√¥ng th·ªÉ g·ªçi ti·∫øn tr√¨nh c√†i Platform Tools." }
      }
      if(!res?.ok){
        appendAdbTerminalOutput(`C√†i Platform Tools th·∫•t b·∫°i: ${res?.error || "kh√¥ng r√µ l·ªói"}`)
        setAdbStatusLine(`C√†i Platform Tools l·ªói: ${res?.error || "kh√¥ng r√µ l·ªói"}`, true)
        alert(res?.error || "C√†i Platform Tools th·∫•t b·∫°i.")
        return
      }
      appendAdbTerminalOutput(`C√†i Platform Tools xong. D√πng adb: ${res.adbCommand || ""}`)
      setAdbStatusLine("ƒê√£ c√†i Platform Tools n·ªôi b·ªô app.")
      await refreshAdbToolsStatus(false)
      alert("ƒê√£ c√†i Android Platform Tools v√†o app.")
    }

    async function linkAdbFromFile(){
      appendAdbTerminalOutput("ƒêang m·ªü h·ªôp tho·∫°i ch·ªçn file...")
      setAdbStatusLine("ƒêang ch·ªçn file Platform Tools...")
      let res = null
      try{
        res = await ipcRenderer.invoke("tools:install-platform-tools-from-file")
      }catch(_e){
        res = { ok: false, error: "Kh√¥ng th·ªÉ m·ªü h·ªôp tho·∫°i ch·ªçn file." }
      }
      if(!res?.ok){
        if(res?.error && res.error !== "Ng∆∞·ªùi d√πng h·ªßy ch·ªçn file"){
          appendAdbTerminalOutput(`C√†i Platform Tools th·∫•t b·∫°i: ${res?.error || "kh√¥ng r√µ l·ªói"}`)
          setAdbStatusLine(`C√†i Platform Tools l·ªói: ${res?.error || "kh√¥ng r√µ l·ªói"}`, true)
          alert(res?.error || "C√†i Platform Tools th·∫•t b·∫°i.")
        }
        return
      }
      appendAdbTerminalOutput(`C√†i Platform Tools xong. D√πng adb: ${res.adbCommand || ""}`)
      setAdbStatusLine("ƒê√£ c√†i Platform Tools t·ª´ file.")
      await refreshAdbToolsStatus(false)
      alert("ƒê√£ c√†i Android Platform Tools t·ª´ file.")
    }

    async function installScrcpyFiles(){
      const scrcpyPath = "/Users/nguyenngoc8386/Downloads/ph·∫ßn m·ªÉm/scrcpy-macos-x86_64-v3.3.4/"
      appendAdbTerminalOutput(`ƒêang c√†i scrcpy t·ª´: ${scrcpyPath}`)
      let res = null
      try{
        res = await ipcRenderer.invoke("adb:install-scrcpy-files", { 
          sourcePath: scrcpyPath 
        })
      }catch(_e){
        res = { ok: false, error: "Kh√¥ng th·ªÉ c√†i scrcpy." }
      }
      if(!res?.ok){
        appendAdbTerminalOutput(`C√†i scrcpy th·∫•t b·∫°i: ${res?.error || "kh√¥ng r√µ l·ªói"}`)
        alert(res?.error || "C√†i scrcpy th·∫•t b·∫°i.")
        return
      }
      if(res.alreadyExists){
        appendAdbTerminalOutput(`File scrcpy ƒë√£ t·ªìn t·∫°i: ${res.fileName || ""}`)
        setAdbStatusLine(`scrcpy ƒë√£ c√≥: ${res.fileName || ""}`)
        alert(`scrcpy ƒë√£ ƒë∆∞·ª£c c√†i tr∆∞·ªõc ƒë√≥: ${res.fileName || ""}`)
        return
      }
      appendAdbTerminalOutput(`C√†i file scrcpy th√†nh c√¥ng: ${res.allFiles || ""}`)
      setAdbStatusLine(`ƒê√£ c√†i scrcpy`)
      alert(`ƒê√£ c√†i scrcpy th√†nh c√¥ng!\nFiles: ${res.allFiles || ""}`)
    }

    window.addEventListener("DOMContentLoaded", async () => {
      loadKqxsLayout()
      setTimeout(async () => {
        appendAdbTerminalOutput("Ki·ªÉm tra scrcpy...")
        try{
          const res = await ipcRenderer.invoke("adb:install-scrcpy-files", { 
            sourcePath: "/Users/nguyenngoc8386/Downloads/ph·∫ßn m·ªÉm/scrcpy-macos-x86_64-v3.3.4/" 
          })
          if(res?.ok && !res.alreadyExists){
            appendAdbTerminalOutput(`ƒê√£ c√†i scrcpy: ${res.allFiles || ""}`)
            setAdbStatusLine("ƒê√£ c√†i scrcpy")
          }
        }catch(_e){}
      }, 2000)
    })

    async function runAdbCommandRaw(command, options={}){
      const raw = String(command || "").trim()
      if(!raw){
        if(!options?.silent){
          alert("B·∫°n ch∆∞a nh·∫≠p l·ªánh ADB.")
        }
        return { ok: false }
      }
      if(adbState.terminalBusy){
        if(!options?.silent){
          alert("ADB terminal ƒëang ch·∫°y l·ªánh kh√°c, vui l√≤ng ch·ªù.")
        }
        return { ok: false }
      }

      adbState.terminalBusy = true
      appendAdbTerminalOutput(`$ adb ${raw}`)
      let res = null
      try{
        res = await ipcRenderer.invoke("adb:run-command", { command: raw, timeoutMs: 60000 })
      }catch(_e){
        res = { ok: false, error: "L·ªói g·ª≠i l·ªánh ADB t·ª´ giao di·ªán." }
      }finally{
        adbState.terminalBusy = false
      }

      if(!res?.ok){
        appendAdbTerminalOutput(`L·ªói: ${res?.error || "ADB command th·∫•t b·∫°i"}`)
        setAdbStatusLine(`ADB l·ªói: ${res?.error || "kh√¥ng r√µ l·ªói"}`, true)
        if(!options?.silent){
          alert(res?.error || "ADB command th·∫•t b·∫°i.")
        }
        return { ok: false, error: res?.error || "" }
      }

      appendAdbTerminalOutput(res.output || "(kh√¥ng c√≥ output)")
      if(!options?.skipStatusRefresh){
        await refreshAdbToolsStatus(false)
      }
      return { ok: true, output: res.output || "" }
    }

    async function runAdbTerminalCommand(){
      const input = document.getElementById("adbTerminalInput")
      const raw = String(input?.value || "").trim()
      if(!raw){
        alert("Nh·∫≠p l·ªánh ADB tr∆∞·ªõc khi ch·∫°y.")
        return
      }
      await runAdbCommandRaw(raw)
    }

    async function runAdbDevicesQuick(){
      const res = await runAdbCommandRaw("devices -l", { silent: true })
      if(!res?.ok){
        alert("Kh√¥ng l·∫•y ƒë∆∞·ª£c danh s√°ch thi·∫øt b·ªã ADB.")
      }
    }

    function setAppRemoteStatusLine(message, isError=false){
      const line = document.getElementById("appRemoteStatusLine")
      if(!line){
        return
      }
      line.textContent = String(message || "")
      line.style.color = isError ? "#dc2626" : ""
    }

    async function refreshAppRemoteStatus(showAlert=false){
      let res = null
      try{
        res = await ipcRenderer.invoke("app-remote:status")
      }catch(_e){
        res = { ok: false, error: "Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c tr·∫°ng th√°i remote app." }
      }
      if(!res?.ok){
        setAppRemoteStatusLine(`Remote App l·ªói: ${res?.error || "kh√¥ng x√°c ƒë·ªãnh"}`, true)
        if(showAlert){
          alert(res?.error || "Kh√¥ng l·∫•y ƒë∆∞·ª£c tr·∫°ng th√°i remote app.")
        }
        return { ok: false }
      }
      adbState.appRemotePort = Number(res.port || adbState.appRemotePort || 17321)
      if(res.running){
        setAppRemoteStatusLine(`Remote App ƒëang ch·∫°y: ${res.url}`)
      }else{
        setAppRemoteStatusLine(`Remote App ƒëang t·∫Øt (port ${res.port}).`)
      }
      return { ok: true, status: res }
    }

    async function startAppRemoteControl(){
      let res = null
      try{
        res = await ipcRenderer.invoke("app-remote:start", { port: adbState.appRemotePort || 17321 })
      }catch(_e){
        res = { ok: false, error: "Kh√¥ng th·ªÉ b·∫≠t remote app." }
      }
      if(!res?.ok){
        setAppRemoteStatusLine(`Remote App l·ªói: ${res?.error || "kh√¥ng r√µ l·ªói"}`, true)
        alert(res?.error || "B·∫≠t remote app th·∫•t b·∫°i.")
        return
      }
      adbState.appRemotePort = Number(res.port || adbState.appRemotePort || 17321)
      setAppRemoteStatusLine(`Remote App ƒëang ch·∫°y: ${res.url}`)
      appendAdbTerminalOutput(`Remote app started at ${res.url}`)
      alert(`ƒê√£ b·∫≠t remote app t·∫°i ${res.url}`)
    }

    async function stopAppRemoteControl(){
      let res = null
      try{
        res = await ipcRenderer.invoke("app-remote:stop")
      }catch(_e){
        res = { ok: false, error: "Kh√¥ng th·ªÉ t·∫Øt remote app." }
      }
      if(!res?.ok){
        setAppRemoteStatusLine(`Remote App l·ªói: ${res?.error || "kh√¥ng r√µ l·ªói"}`, true)
        alert(res?.error || "T·∫Øt remote app th·∫•t b·∫°i.")
        return
      }
      setAppRemoteStatusLine(`Remote App ƒëang t·∫Øt (port ${res.port}).`)
      appendAdbTerminalOutput("Remote app stopped.")
    }

    async function enableAppRemoteReverse(transport){
      const status = await refreshAppRemoteStatus(false)
      if(!status?.ok || !status.status?.running){
        await startAppRemoteControl()
      }

      let serial = ""
      const normalized = String(transport || "").trim().toLowerCase()
      if(normalized === "wifi"){
        if(!adbState.wifiSerial){
          const connected = await connectAdbWifi({ silent: true })
          if(!connected?.ok){
            return
          }
        }
        serial = adbState.wifiSerial
      }

      let res = null
      try{
        res = await ipcRenderer.invoke("app-remote:adb-reverse", {
          transport: normalized,
          serial,
          remotePort: adbState.appRemotePort || 17321,
          localPort: adbState.appRemotePort || 17321
        })
      }catch(_e){
        res = { ok: false, error: "Kh√¥ng th·ªÉ b·∫≠t adb reverse." }
      }

      if(!res?.ok){
        appendAdbTerminalOutput(`ADB reverse l·ªói: ${res?.error || "kh√¥ng r√µ l·ªói"}`)
        alert(res?.error || "ADB reverse th·∫•t b·∫°i.")
        return
      }
      appendAdbTerminalOutput(`ADB reverse OK (${res.serial}): ${res.reverse}`)
      alert(`ADB reverse OK (${res.serial}). M·ªü http://127.0.0.1:${adbState.appRemotePort || 17321} tr√™n Android.`)
    }

    async function enableAppRemoteReverseUsb(){
      await enableAppRemoteReverse("usb")
    }

    async function enableAppRemoteReverseWifi(){
      await enableAppRemoteReverse("wifi")
    }

    async function runAdbRemoteAction(action, payload={}, options={}){
      let transport = String(options?.transport || "auto").toLowerCase()
      let serial = String(options?.serial || "").trim()

      if(transport === "auto"){
        transport = adbState.wifiSerial ? "wifi" : "usb"
      }
      if(transport === "wifi"){
        if(!adbState.wifiSerial){
          const connected = await connectAdbWifi({ silent: true })
          if(!connected?.ok){
            return { ok: false }
          }
        }
        serial = adbState.wifiSerial
      }

      let res = null
      try{
        res = await ipcRenderer.invoke("adb:remote-action", {
          action,
          transport,
          serial,
          ...payload
        })
      }catch(_e){
        res = { ok: false, error: "Kh√¥ng g·ª≠i ƒë∆∞·ª£c remote action." }
      }

      if(!res?.ok){
        appendAdbTerminalOutput(`Remote Android l·ªói (${action}): ${res?.error || "kh√¥ng r√µ l·ªói"}`)
        alert(res?.error || "Remote Android th·∫•t b·∫°i.")
        return { ok: false }
      }
      appendAdbTerminalOutput(`Remote Android OK: ${action} (${res.serial || ""})`)
      return { ok: true }
    }

    async function remoteAndroidBack(){ await runAdbRemoteAction("back") }
    async function remoteAndroidHome(){ await runAdbRemoteAction("home") }
    async function remoteAndroidRecent(){ await runAdbRemoteAction("recent") }
    async function remoteAndroidPower(){ await runAdbRemoteAction("power") }
    async function remoteAndroidVolumeUp(){ await runAdbRemoteAction("volume_up") }
    async function remoteAndroidVolumeDown(){ await runAdbRemoteAction("volume_down") }
    async function remoteAndroidSendText(){
      const input = document.getElementById("adbRemoteTextInput")
      const text = String(input?.value || "").trim()
      if(!text){
        alert("Nh·∫≠p text tr∆∞·ªõc khi g·ª≠i v√†o Android.")
        return
      }
      const res = await runAdbRemoteAction("text", { text })
      if(res?.ok && input){
        input.value = ""
      }
    }

    async function startAdbMirrorAuto(){
      const preferred = adbState.wifiSerial ? "wifi" : "usb"
      if(preferred === "wifi"){
        await startAdbMirrorWifi()
      }else{
        await startAdbMirrorUsb()
      }
    }

    function parseAdbWifiEndpointInput(raw){
      const value = String(raw || "").trim()
        .replace(/^adb:\/\//i, "")
        .replace(/^https?:\/\//i, "")
      if(!value){
        return null
      }
      const parts = value.split(":")
      const host = String(parts[0] || "").trim()
      let port = ADB_DEFAULT_TCP_PORT
      if(parts.length > 1){
        const customPort = Number.parseInt(String(parts[1] || "").trim(), 10)
        if(Number.isFinite(customPort) && customPort > 0){
          port = customPort
        }
      }
      if(!host){
        return null
      }
      return {
        host,
        port,
        target: `${host}:${port}`
      }
    }

    async function connectAdbWifi(options={}){
      const promptSeed = adbState.wifiHost || ""
      const input = prompt("Nh·∫≠p IP Android (VD: 192.168.1.20 ho·∫∑c 192.168.1.20:5555)", promptSeed)
      if(input === null){
        return { ok: false, cancelled: true }
      }

      const endpoint = parseAdbWifiEndpointInput(input)
      if(!endpoint){
        alert("IP ADB WiFi kh√¥ng h·ª£p l·ªá.")
        return { ok: false }
      }

      let res = null
      try{
        res = await ipcRenderer.invoke("adb:connect-wifi", endpoint)
      }catch(_e){
        res = { ok: false, error: "Kh√¥ng th·ªÉ g·ªçi ADB WiFi trong app." }
      }

      if(!res?.ok){
        appendAdbTerminalOutput(`ADB WiFi l·ªói: ${res?.error || "kh√¥ng r√µ l·ªói"}`)
        alert(res?.error || "K·∫øt n·ªëi ADB WiFi th·∫•t b·∫°i.")
        return { ok: false }
      }

      adbState.wifiHost = endpoint.target
      adbState.wifiSerial = String(res.target || endpoint.target)
      appendAdbTerminalOutput(`ADB WiFi connected: ${adbState.wifiSerial}`)
      await refreshAdbToolsStatus(false)
      if(!options?.silent){
        alert(`ADB WiFi ƒë√£ k·∫øt n·ªëi: ${adbState.wifiSerial}`)
      }
      return { ok: true, serial: adbState.wifiSerial }
    }

    async function runAdbMirror(transport){
      let serial = ""
      if(transport === "wifi"){
        if(!adbState.wifiSerial){
          const connected = await connectAdbWifi({ silent: true })
          if(!connected?.ok){
            return
          }
        }
        serial = adbState.wifiSerial
      }

      let res = null
      try{
        res = await ipcRenderer.invoke("adb:mirror", { transport, serial })
      }catch(_e){
        res = { ok: false, error: "Kh√¥ng th·ªÉ ch·∫°y l·ªánh mirror ADB." }
      }

      if(!res?.ok){
        appendAdbTerminalOutput(`Mirror ${transport} l·ªói: ${res?.error || "kh√¥ng r√µ l·ªói"}`)
        alert(res?.error || "M·ªü mirror th·∫•t b·∫°i.")
        return
      }

      if(transport === "wifi" && res.serial){
        adbState.wifiSerial = String(res.serial)
      }
      appendAdbTerminalOutput(`ƒê√£ m·ªü mirror ${transport}: ${res.serial || ""}`)
      await refreshAdbToolsStatus(false)
      alert(`ƒê√£ m·ªü ph·∫£n chi·∫øu m√†n h√¨nh Android (${res.serial || transport}).`)
    }

    async function startAdbMirrorUsb(){
      await runAdbMirror("usb")
    }

    async function startAdbMirrorWifi(){
      await runAdbMirror("wifi")
    }

    async function runAdbCameraAction(action, transport){
      let serial = ""
      if(transport === "wifi"){
        if(!adbState.wifiSerial){
          const connected = await connectAdbWifi({ silent: true })
          if(!connected?.ok){
            return
          }
        }
        serial = adbState.wifiSerial
      }

      const channel = action === "capture" ? "adb:camera-shutter" : "adb:camera-open"
      let res = null
      try{
        res = await ipcRenderer.invoke(channel, { transport, serial })
      }catch(_e){
        res = { ok: false, error: "Kh√¥ng th·ªÉ g·ª≠i l·ªánh camera qua ADB." }
      }

      if(!res?.ok){
        appendAdbTerminalOutput(`Camera ${transport} l·ªói: ${res?.error || "kh√¥ng r√µ l·ªói"}`)
        alert(res?.error || "L·ªánh camera th·∫•t b·∫°i.")
        return
      }

      if(transport === "wifi" && res.serial){
        adbState.wifiSerial = String(res.serial)
      }
      if(action === "capture"){
        appendAdbTerminalOutput(`ƒê√£ g·ª≠i l·ªánh ch·ª•p ·∫£nh (${res.serial || transport})`)
        alert(`ƒê√£ g·ª≠i l·ªánh ch·ª•p ·∫£nh (${res.serial || transport}).`)
      }else{
        appendAdbTerminalOutput(`ƒê√£ m·ªü camera (${res.serial || transport})`)
        alert(`ƒê√£ m·ªü camera Android (${res.serial || transport}).`)
      }
    }

    async function openAndroidCameraUsb(){
      await runAdbCameraAction("open", "usb")
    }

    async function openAndroidCameraWifi(){
      await runAdbCameraAction("open", "wifi")
    }

    async function captureAndroidPhotoUsb(){
      await runAdbCameraAction("capture", "usb")
    }

    async function captureAndroidPhotoWifi(){
      await runAdbCameraAction("capture", "wifi")
    }

    function normalizeNavigationInput(raw){
      const value = String(raw || "").trim()
      if(!value){
        return ""
      }
      if(/^https?:\/\//i.test(value)){
        return value
      }
      if(value.includes(" ") || !value.includes(".")){
        return `https://www.google.com/search?q=${encodeURIComponent(value)}`
      }
      return `https://${value}`
    }

    function navigateTo(url, options={}){
      const target = String(url || "").trim()
      if(!target){
        return
      }
      const web = getActiveWebview()
      if(!web){
        return
      }
      showBrowserPanel()
      const finalUrl = resolveVietnameseNavigationUrl(target, options)
      updateUrlInput(getDisplayUrl(finalUrl || target))
      web.src = finalUrl || target
    }

    function openAgentGPT(){
      openAiToolById("agentgpt")
    }

    function openChatGPT(){
      openAiToolById("chatgpt")
    }

    function openOpenAI(){
      openChatGPT()
    }

    function openLotoAI(){
      openAiToolById("lotoai")
    }

    function loginGemini(){
      openGeminiAI()
    }

    function openAssistant(){
      openAiToolById("lotoai")
    }

    function openGeminiAI(){
      document.getElementById("geminiAiModal").classList.add("show")
      const input = document.getElementById("geminiAiInput")
      if(input) input.focus()
      renderGeminiAiMessages()
    }

    function closeGeminiAiModal(){
      document.getElementById("geminiAiModal").classList.remove("show")
    }

    function toggleGeminiFloatPanel(){
      const panel = document.getElementById("geminiFloatPanel")
      if(panel.classList.contains("show")){
        panel.classList.remove("show")
      }else{
        panel.classList.add("show")
        renderGeminiFloatMessages()
        const input = document.getElementById("geminiFloatInput")
        if(input) input.focus()
      }
    }

    function setGeminiFloatMeta(text){
      const el = document.getElementById("geminiFloatMeta")
      if(el) el.textContent = text
    }

    function renderGeminiFloatMessages(){
      const log = document.getElementById("geminiFloatLog")
      if(!log) return
      if(!Array.isArray(geminiAiState.messages) || !geminiAiState.messages.length){
        log.innerHTML = '<div style="color:#64748b;font-size:12px;text-align:center;padding:20px;">Nh·∫≠p l·ªánh ƒë·ªÉ AI ƒëi·ªÅu khi·ªÉn app</div>'
        return
      }
      log.innerHTML = geminiAiState.messages.slice(-20).map((msg)=>{
        const isUser = msg.role === "user"
        return `<div class="lotoai-msg ${isUser?"user":"assistant"}">${escapeHtml(msg.content)}</div>`
      }).join("")
      log.scrollTop = log.scrollHeight
    }

    function escapeHtml(text){
      const div = document.createElement("div")
      div.textContent = text
      return div.innerHTML
    }

    async function sendGeminiFloatMessage(){
      const input = document.getElementById("geminiFloatInput")
      const sendBtn = document.getElementById("geminiFloatSendBtn")
      const prompt = String(input?.value || "").trim()
      if(!prompt || geminiAiState.loading) return

      geminiAiState.loading = true
      if(sendBtn){
        sendBtn.disabled = true
        sendBtn.textContent = "..."
      }

      geminiAiState.messages.push({ role: "user", content: prompt })
      if(geminiAiState.messages.length > 50){
        geminiAiState.messages = geminiAiState.messages.slice(-50)
      }
      input.value = ""
      renderGeminiFloatMessages()
      setGeminiFloatMeta("ƒêang x·ª≠ l√Ω...")

      try{
        const apiKey = String(appSettings.ai.geminiApiKey || "AIzaSyCKCsA3vlfOZLOrbYrnzCrD4rYNcwHPFqM").trim()
        const modelSelect = document.getElementById("geminiModel")
        const model = modelSelect?.value || "gemini-2.0-flash"

        const res = await ipcRenderer.invoke("gemini:chat", {
          apiKey,
          model,
          prompt,
          messages: geminiAiState.messages.slice(-10)
        })

        if(res?.ok && res.reply){
          geminiAiState.messages.push({ role: "assistant", content: res.reply })
          if(geminiAiState.messages.length > 50){
            geminiAiState.messages = geminiAiState.messages.slice(-50)
          }
          setGeminiFloatMeta("Ho√†n t·∫•t - AI ƒëi·ªÅu khi·ªÉn: web, adb, mirror, lens, camera...")
          if(res.tool){
            setGeminiFloatMeta("ƒê√£ ch·∫°y: " + res.tool)
          }
        }else{
          geminiAiState.messages.push({ role: "assistant", content: "L·ªói: " + (res?.error || "Kh√¥ng r√µ") })
          setGeminiFloatMeta("L·ªói: " + (res?.error || ""))
        }
      }catch(e){
        geminiAiState.messages.push({ role: "assistant", content: "L·ªói: " + String(e) })
        setGeminiFloatMeta("L·ªói: " + String(e))
      }

      geminiAiState.loading = false
      if(sendBtn){
        sendBtn.disabled = false
        sendBtn.textContent = "G·ª≠i"
      }
      renderGeminiFloatMessages()
    }

    document.getElementById("geminiFloatInput")?.addEventListener("keydown", (e)=>{
      if(e.key === "Enter" && !e.shiftKey){
        e.preventDefault()
        sendGeminiFloatMessage()
      }
    })

    function setGeminiAiLoading(loading){
      geminiAiState.loading = Boolean(loading)
      const sendBtn = document.getElementById("geminiAiSendBtn")
      if(sendBtn){
        sendBtn.disabled = geminiAiState.loading
        sendBtn.textContent = geminiAiState.loading ? "ƒêang x·ª≠ l√Ω..." : "G·ª≠i Gemini"
      }
    }

    function setGeminiAiMeta(text){
      const el = document.getElementById("geminiAiMeta")
      if(el) el.textContent = text
    }

    function pushGeminiAiMessage(role, text){
      geminiAiState.messages.push({ role: role === "assistant" ? "assistant" : "user", content: text })
      if(geminiAiState.messages.length > 50){
        geminiAiState.messages = geminiAiState.messages.slice(-50)
      }
      renderGeminiAiMessages()
    }

    function renderGeminiAiMessages(){
      const log = document.getElementById("geminiAiLog")
      if(!log) return
      if(!Array.isArray(geminiAiState.messages) || !geminiAiState.messages.length){
        log.innerHTML = `<div class="lotoai-msg assistant">Gemini AI s·∫µn s√†ng. B·∫°n c√≥ th·ªÉ y√™u c·∫ßu: "m·ªü google.com", "ch·ª•p lens ocr", "adb devices", "mirror wifi", ho·∫∑c b·∫•t k·ª≥ l·ªánh n√†o.</div>`
        return
      }
      log.innerHTML = geminiAiState.messages.map((msg)=>{
        const roleClass = msg.role === "assistant" ? "assistant" : "user"
        const roleLabel = msg.role === "assistant" ? "Gemini" : "B·∫°n"
        return `<div class="lotoai-msg ${roleClass}"><strong>${roleLabel}:</strong> ${escapeHtml(msg.content)}</div>`
      }).join("")
      log.scrollTop = log.scrollHeight
    }

    function clearGeminiAiChat(){
      geminiAiState.messages = []
      renderGeminiAiMessages()
    }

    async function testGeminiConnection(){
      let apiKey = String(appSettings.ai.geminiApiKey || "").trim()
      if(!apiKey){
        const inputKey = prompt("Nh·∫≠p Google Gemini API Key:")
        if(!inputKey || !inputKey.trim()){
          return
        }
        apiKey = inputKey.trim()
        appSettings.ai.geminiApiKey = apiKey
        persistAppSettings()
      }
      setGeminiAiMeta("ƒêang ki·ªÉm tra k·∫øt n·ªëi Gemini...")
      try{
        const res = await ipcRenderer.invoke("gemini:chat", {
          apiKey,
          model: "gemini-2.0-flash",
          messages: [{ role: "user", content: "ping" }]
        })
        if(res?.ok){
          setGeminiAiMeta("K·∫øt n·ªëi Gemini th√†nh c√¥ng! Model: " + (res.model || ""))
          document.getElementById("settingGeminiApiKey").value = apiKey
          persistAppSettings()
          alert("K·∫øt n·ªëi Gemini th√†nh c√¥ng! API Key ƒë√£ ƒë∆∞·ª£c l∆∞u.")
        }else{
          appSettings.ai.geminiApiKey = ""
          setGeminiAiMeta("L·ªói: " + (res?.error || "Kh√¥ng r√µ"))
          alert("L·ªói k·∫øt n·ªëi: " + (res?.error || "Kh√¥ng r√µ"))
        }
      }catch(e){
        setGeminiAiMeta("L·ªói: " + e.message)
        alert("L·ªói: " + e.message)
      }
    }

    async function sendGeminiAiMessage(){
      if(geminiAiState.loading) return
      const input = document.getElementById("geminiAiInput")
      const prompt = String(input?.value || "").trim()
      if(!prompt){
        alert("B·∫°n ch∆∞a nh·∫≠p n·ªôi dung cho Gemini AI.")
        return
      }

      pushGeminiAiMessage("user", prompt)
      input.value = ""
      setGeminiAiLoading(true)

      try{
        const commandApplied =
          (await executeVietnameseCommand(prompt)) ||
          (await executeAiControlCommand(prompt, { source: "gemini" }))

        if(commandApplied){
          pushGeminiAiMessage("assistant", "ƒê√£ th·ª±c thi l·ªánh ƒëi·ªÅu khi·ªÉn app theo y√™u c·∫ßu.")
          setGeminiAiLoading(false)
          return
        }

        const apiKey = String(appSettings.ai.geminiApiKey || "").trim()
        if(!apiKey){
          pushGeminiAiMessage("assistant", "Ch∆∞a c√≥ Gemini API Key. V√†o C√†i ƒë·∫∑t ‚Üí nh·∫≠p Google Gemini API Key.")
          setGeminiAiLoading(false)
          return
        }

        const modelSelect = document.getElementById("geminiModel")
        const model = modelSelect?.value || "gemini-2.0-flash"
        
        setGeminiAiMeta(`ƒêang chat v·ªõi Gemini ${model}...`)
        
        const systemPrompt = `B·∫°n l√† AI assistant ƒëi·ªÅu khi·ªÉn app Comet Ultra. B·∫°n c√≥ quy·ªÅn ƒëi·ªÅu khi·ªÉn ƒë·∫ßy ƒë·ªß app bao g·ªìm:
- M·ªü/ƒëi·ªÅu khi·ªÉn web: m·ªü URL, quay l·∫°i, ti·∫øn t·ªõi, t·∫£i l·∫°i, zoom
- ADB Android: adb devices, adb shell, mirror usb/wifi, camera, ch·ª•p ·∫£nh
- Lens OCR/AI: ch·ª•p m√†n h√¨nh, nh·∫≠n d·∫°ng vƒÉn b·∫£n, ph√¢n t√≠ch h√¨nh ·∫£nh
- Terminal: ch·∫°y l·ªánh shell
- C√†i ƒë·∫∑t: c√†i adb, c√†i scrcpy, ki·ªÉm tra tools
- Web: t√¨m ki·∫øm, d·ªãch web, thay ƒë·ªïi ng√¥n ng·ªØ

Khi user y√™u c·∫ßu th·ª±c hi·ªán h√†nh ƒë·ªông, h√£y th·ª±c hi·ªán l·ªánh tr·ª±c ti·∫øp. N·∫øu c·∫ßn x√°c nh·∫≠n, h√£y h·ªèi user.`

        const res = await ipcRenderer.invoke("gemini:chat", {
          apiKey,
          model,
          systemPrompt,
          prompt,
          messages: geminiAiState.messages.slice(-10)
        })
        
        if(!res || !res.ok){
          pushGeminiAiMessage("assistant", res?.error || "L·ªói g·ªçi Gemini API.")
          return
        }
        pushGeminiAiMessage("assistant", String(res.reply || ""))
        setGeminiAiMeta("Gemini AI s·∫µn s√†ng.")
      }catch(e){
        pushGeminiAiMessage("assistant", "L·ªói k·∫øt n·ªëi: " + e.message)
      }finally{
        setGeminiAiLoading(false)
      }
    }

    function getToolSourceUrl(tool){
      const directUrl = normalizeToolUrl(tool?.url || "")
      if(!directUrl){
        return ""
      }
      if(tool?.id === "agentgpt"){
        return directUrl
      }
      return directUrl
    }

    function extractHostFromUrl(rawUrl){
      try{
        const parsed = new URL(String(rawUrl || ""))
        if(parsed.hostname.includes("translate.google")){
          const target = extractTranslateTargetUrl(rawUrl)
          if(target){
            return extractHostFromUrl(target)
          }
        }
        return parsed.hostname.replace(/^www\./i, "")
      }catch(_e){
        return ""
      }
    }

    function detectCurrentAiToolIndex(enabledTools){
      if(activeAiToolId){
        const activeIndex = enabledTools.findIndex((tool)=>tool.id === activeAiToolId)
        if(activeIndex >= 0){
          return activeIndex
        }
      }
      const web = getActiveWebview()
      const currentUrl = web?.getURL?.() || web?.src || ""
      const currentHost = extractHostFromUrl(currentUrl)
      if(!currentHost){
        return -1
      }

      return enabledTools.findIndex((tool)=>{
        const toolHost = extractHostFromUrl(getToolSourceUrl(tool))
        if(!toolHost){
          return false
        }
        return currentHost === toolHost || currentHost.endsWith(`.${toolHost}`) || toolHost.endsWith(`.${currentHost}`)
      })
    }

    function switchAiTool(step=1, notify=true){
      const enabledTools = getEnabledTools()
      if(!enabledTools.length){
        if(notify){
          alert("Ch∆∞a c√≥ c√¥ng c·ª• AI n√†o ƒëang b·∫≠t.")
        }
        return false
      }

      const currentIndex = detectCurrentAiToolIndex(enabledTools)
      const baseIndex = currentIndex >= 0 ? currentIndex : -1
      const offset = Number.isFinite(step) ? Math.trunc(step) : 1
      const nextIndex = ((baseIndex + offset) % enabledTools.length + enabledTools.length) % enabledTools.length
      const nextTool = enabledTools[nextIndex]

      const opened = openAiToolById(nextTool.id)
      if(opened && notify){
        const switchBtn = document.getElementById("aiSwitchBtn")
        if(switchBtn){
          switchBtn.textContent = `AI: ${nextTool.name}`
          setTimeout(()=>{
            switchBtn.textContent = "AI Switch"
          }, 1200)
        }
      }
      return opened
    }

    function updateMicButton(){
      const buttons = ["micCommandBtn", "settingMicBtn"]
        .map((id)=>document.getElementById(id))
        .filter(Boolean)
      if(!buttons.length){
        return
      }
      buttons.forEach((btn)=>{
        if(isVoiceListening){
          btn.textContent = "Mic: ON"
          btn.classList.add("scan-btn")
        }else{
          btn.textContent = "Mic"
          btn.classList.remove("scan-btn")
        }
      })
    }

    function getSpeechRecognitionCtor(){
      return window.SpeechRecognition || window.webkitSpeechRecognition || null
    }

    function stopVoiceCommand(){
      if(voiceRecognition){
        try{
          voiceRecognition.stop()
        }catch(_e){
          // Ignore stop errors.
        }
      }
      isVoiceListening = false
      updateMicButton()
    }

    async function executeVoiceTranscript(transcript){
      const command = String(transcript || "").trim()
      if(!command){
        return
      }

      updateUrlInput(command)
      if(await executeVietnameseCommand(command)){
        return
      }
      if(await executeAiControlCommand(command, { notify: true })){
        return
      }
      navigateTo(normalizeNavigationInput(command))
    }

    async function toggleVoiceCommand(){
      if(isVoiceListening){
        stopVoiceCommand()
        return
      }

      const SpeechCtor = getSpeechRecognitionCtor()
      if(!SpeechCtor){
        alert("Tr√¨nh duy·ªát trong app ch∆∞a h·ªó tr·ª£ nh·∫≠n di·ªán gi·ªçng n√≥i.")
        return
      }

      if(!voiceRecognition){
        voiceRecognition = new SpeechCtor()
        voiceRecognition.lang = "vi-VN"
        voiceRecognition.interimResults = false
        voiceRecognition.continuous = false
        voiceRecognition.maxAlternatives = 1

        voiceRecognition.onstart = ()=>{
          isVoiceListening = true
          updateMicButton()
        }

        voiceRecognition.onend = ()=>{
          isVoiceListening = false
          updateMicButton()
        }

        voiceRecognition.onerror = (event)=>{
          isVoiceListening = false
          updateMicButton()
          const code = String(event?.error || "")
          if(code && code !== "no-speech"){
            alert(`Mic l·ªói: ${code}`)
          }
        }

        voiceRecognition.onresult = async (event)=>{
          const transcript = String(event?.results?.[0]?.[0]?.transcript || "").trim()
          await executeVoiceTranscript(transcript)
        }
      }

      try{
        voiceRecognition.start()
      }catch(_e){
        alert("Kh√¥ng th·ªÉ b·∫≠t micro. H√£y th·ª≠ l·∫°i.")
      }
    }

    async function applyVietnameseForAgentGPT(web, notify=false){
      const activeWeb = web || getActiveWebview()
      const currentUrl = activeWeb?.getURL?.() || activeWeb?.src || ""
      if(!activeWeb || !isAgentGPTUrl(currentUrl)){
        if(notify){
          alert("H√£y m·ªü AgentGPT tr∆∞·ªõc r·ªìi b·∫≠t ti·∫øng Vi·ªát.")
        }
        return false
      }

      const viScript = `
        (() => {
          const dictionary = ${JSON.stringify(AGENT_GPT_VI_DICTIONARY)}
          const replaceText = (value) => {
            let output = String(value || "")
            Object.keys(dictionary).forEach((key) => {
              if (output.includes(key)) {
                output = output.split(key).join(dictionary[key])
              }
            })
            return output
          }

          const walk = (node) => {
            if (!node) return
            if (node.nodeType === Node.TEXT_NODE) {
              const original = node.textContent || ""
              const next = replaceText(original)
              if (next !== original) {
                node.textContent = next
              }
              return
            }
            if (node.nodeType !== Node.ELEMENT_NODE) return

            ;["placeholder", "title", "aria-label"].forEach((attr) => {
              const val = node.getAttribute && node.getAttribute(attr)
              if (!val) return
              const next = replaceText(val)
              if (next !== val) {
                node.setAttribute(attr, next)
              }
            })

            node.childNodes.forEach(walk)
          }

          document.documentElement.setAttribute("lang", "vi")
          if (document.body) {
            walk(document.body)
          }

          if (window.__agentgptViObserver) {
            window.__agentgptViObserver.disconnect()
          }
          const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
              if (mutation.type === "characterData") {
                walk(mutation.target)
              } else {
                mutation.addedNodes.forEach(walk)
              }
            })
          })
          if (document.body) {
            observer.observe(document.body, { childList: true, subtree: true, characterData: true })
          }
          window.__agentgptViObserver = observer
          return "ok"
        })()
      `

      try{
        await activeWeb.executeJavaScript(viScript, true)
        if(notify){
          alert("ƒê√£ b·∫≠t Vi·ªát h√≥a cho giao di·ªán AgentGPT trong app.")
        }
        return true
      }catch(_e){
        if(notify){
          alert("Kh√¥ng th·ªÉ b·∫≠t Vi·ªát h√≥a AgentGPT ·ªü trang hi·ªán t·∫°i.")
        }
        return false
      }
    }

    function scheduleAgentGPTEnhancement(web){
      if(!web){
        return
      }
      setTimeout(()=>{ applyVietnameseForAgentGPT(web) }, 120)
      setTimeout(()=>{ applyVietnameseForAgentGPT(web) }, 850)
    }

    function extractFirstJsonObject(rawText){
      const text = String(rawText || "").trim()
      if(!text){
        return null
      }
      try{
        return JSON.parse(text)
      }catch(_e){
        // Continue with slice parse.
      }
      const start = text.indexOf("{")
      const end = text.lastIndexOf("}")
      if(start === -1 || end === -1 || end <= start){
        return null
      }
      try{
        return JSON.parse(text.slice(start, end + 1))
      }catch(_e){
        return null
      }
    }

    function parseAiAction(rawText){
      const parsed = extractFirstJsonObject(rawText)
      if(!parsed || typeof parsed !== "object"){
        return null
      }
      const action = normalizeVietnameseCommand(parsed.action || "")
      if(!action){
        return null
      }
      return {
        action,
        target: String(parsed.target || "").trim(),
        value: String(parsed.value || "").trim(),
        toolId: String(parsed.toolId || "").trim(),
        message: String(parsed.message || "").trim()
      }
    }

    async function applyAiAction(actionData){
      const action = normalizeVietnameseCommand(actionData?.action || "")
      const target = String(actionData?.target || "").trim()
      const value = String(actionData?.value || "").trim()
      const toolId = String(actionData?.toolId || "").trim()
      const mergedValue = value || target

      if(action === "none"){
        return false
      }
      if(action === "open_tool"){
        const token = normalizeVietnameseCommand(toolId || mergedValue)
        if(!token){
          return false
        }
        const byId = appSettings.ai.tools.find((tool)=>normalizeVietnameseCommand(tool.id) === token)
        if(byId){
          return openAiToolById(byId.id)
        }
        const byName = appSettings.ai.tools.find((tool)=>normalizeVietnameseCommand(tool.name) === token)
        if(byName){
          return openAiToolById(byName.id)
        }
        return false
      }
      if(action === "switch_ai"){
        const direction = normalizeVietnameseCommand(mergedValue)
        const step = direction.includes("prev") || direction.includes("truoc") || direction.includes("lui") ? -1 : 1
        return switchAiTool(step, true)
      }
      if(action === "navigate_url"){
        if(!mergedValue){
          return false
        }
        navigateTo(normalizeNavigationInput(mergedValue))
        return true
      }
      if(action === "search_web"){
        if(!mergedValue){
          return false
        }
        navigateTo(`https://www.google.com/search?q=${encodeURIComponent(mergedValue)}`)
        return true
      }
      if(action === "show_kqxs"){
        showHistoryPanel()
        return true
      }
      if(action === "show_browser"){
        showBrowserPanel()
        return true
      }
      if(action === "open_settings"){
        openSettingsModal()
        return true
      }
      if(action === "open_ai_settings"){
        openSettingsModal()
        switchSettingsTab("ai")
        return true
      }
      if(action === "back"){
        goBack()
        return true
      }
      if(action === "forward"){
        goForward()
        return true
      }
      if(action === "reload"){
        reload()
        return true
      }
      if(action === "theme_dark"){
        setThemeDark(true, true)
        return true
      }
      if(action === "theme_light"){
        setThemeDark(false, true)
        return true
      }
      if(action === "theme_toggle"){
        toggleTheme()
        return true
      }
      if(action === "lens_print"){
        printLatestTicket()
        return true
      }
      if(action === "lens_ocr"){
        startLensOcr()
        return true
      }
      if(action === "lens_ai"){
        startLensAi()
        return true
      }
      if(action === "zoom_in"){
        zoomStep(10)
        return true
      }
      if(action === "zoom_out"){
        zoomStep(-10)
        return true
      }
      if(action === "zoom_set"){
        const zoomValue = Number(mergedValue)
        if(Number.isFinite(zoomValue)){
          document.getElementById("zoomPercent").value = String(Math.max(30, Math.min(300, Math.round(zoomValue))))
          applyZoom()
          return true
        }
        return false
      }
      if(action === "run_command"){
        if(!mergedValue){
          return false
        }
        return executeVietnameseCommand(mergedValue)
      }
      return false
    }

    async function executeAiControlCommand(raw, options={}){
      const command = String(raw || "").trim()
      if(!command){
        return false
      }

      const source = String(options?.source || "input")
      const web = getActiveWebview()
      const currentUrl = web?.getURL?.() || web?.src || ""
      const payload = {
        command,
        source,
        currentUrl,
        availableTools: getEnabledTools().map((tool)=>({
          id: tool.id,
          name: tool.name,
          url: normalizeToolUrl(tool.url)
        }))
      }

      try{
        const rawRes = await ipcRenderer.invoke("ask-ai", payload)
        const parsed = parseAiAction(rawRes)
        if(!parsed){
          return false
        }
        return Boolean(await applyAiAction(parsed))
      }catch(_e){
        return false
      }
    }

    async function executeVietnameseCommand(raw){
      const command = String(raw || "").trim()
      if(!command){
        return false
      }

      const normalized = normalizeVietnameseCommand(command)
      if(!normalized){
        return false
      }

      if(["cai dat","mo cai dat","settings","setting"].includes(normalized)){
        openSettingsModal()
        return true
      }
      if(["cong cu ai","mo cong cu ai"].includes(normalized)){
        openSettingsModal()
        switchSettingsTab("ai")
        return true
      }
      if(["agentgpt","mo agentgpt","mo agent gpt","mo ai"].includes(normalized)){
        openAgentGPT()
        return true
      }
      if(["chatgpt","chat gpt","mo chatgpt","mo chat gpt","openai","mo openai","mo open ai"].includes(normalized)){
        openChatGPT()
        return true
      }
      if(["lotoai","mo lotoai","mo loto ai","loto ai"].includes(normalized)){
        openLotoAI()
        return true
      }
      if(["llama2","llama 2","mo llama2","mo llama 2","llama2 7b"].includes(normalized)){
        openAiToolById("ollama_llama2_7b")
        return true
      }
      if(["alpaca","mo alpaca","alpaca 7b"].includes(normalized)){
        openAiToolById("ollama_alpaca_7b")
        return true
      }
      if(["vicuna","mo vicuna","vicuna 7b"].includes(normalized)){
        openAiToolById("ollama_vicuna_7b")
        return true
      }
      if(["mistral mini","mo mistral","mistral"].includes(normalized)){
        openAiToolById("ollama_mistral_mini")
        return true
      }
      if(["tinytext","tiny","nanogpt","tinyllama"].includes(normalized)){
        openAiToolById("ollama_tiny")
        return true
      }
      if(["gptq","gptq 4bit","4bit"].includes(normalized)){
        openAiToolById("ollama_gptq_4bit")
        return true
      }
      if(["pull model","pull ollama","tai model","tai model local"].includes(normalized)){
        openLotoAI()
        pullSelectedLotoAiModel()
        return true
      }
      if(["pull all","pull tat ca","tai tat ca model","tai full model"].includes(normalized)){
        openLotoAI()
        pullAllLotoAiPresets()
        return true
      }
      if(["ai switch","ai swich","switch ai","doi ai","chuyen ai","doi cong cu ai"].includes(normalized)){
        switchAiTool()
        return true
      }
      if(["mic","micro","bat mic","tat mic","lenh giong noi"].includes(normalized)){
        toggleVoiceCommand()
        return true
      }
      if(["quay lai","back","lui"].includes(normalized)){
        goBack()
        return true
      }
      if(["tien toi","tiep","forward"].includes(normalized)){
        goForward()
        return true
      }
      if(["tai lai","reload","f5"].includes(normalized)){
        reload()
        return true
      }
      if(["dich web","dich trang","translate web","translate page"].includes(normalized)){
        await translateCurrentWeb()
        return true
      }
      if(["ngon ngu goc","ve ngon ngu goc","hien thi goc","trang goc"].includes(normalized)){
        await restoreOriginalWebLanguage()
        return true
      }
      if(["cai adb","cai platform tools","cai android platform tools"].includes(normalized)){
        await installAndroidPlatformTools()
        return true
      }
      if(["adb devices","kiem tra adb","adb terminal"].includes(normalized)){
        await runAdbDevicesQuick()
        return true
      }
      if(["adb wifi","ket noi adb wifi","wifi adb"].includes(normalized)){
        await connectAdbWifi()
        return true
      }
      if(["mirror usb","adb mirror usb","phan chieu usb"].includes(normalized)){
        await startAdbMirrorUsb()
        return true
      }
      if(["mirror wifi","adb mirror wifi","phan chieu wifi"].includes(normalized)){
        await startAdbMirrorWifi()
        return true
      }
      if(["camera usb","cam usb","mo camera usb","mo may anh usb"].includes(normalized)){
        await openAndroidCameraUsb()
        return true
      }
      if(["camera wifi","cam wifi","mo camera wifi","mo may anh wifi"].includes(normalized)){
        await openAndroidCameraWifi()
        return true
      }
      if(["chup usb","chup anh usb","shutter usb"].includes(normalized)){
        await captureAndroidPhotoUsb()
        return true
      }
      if(["chup wifi","chup anh wifi","shutter wifi"].includes(normalized)){
        await captureAndroidPhotoWifi()
        return true
      }
      if(["mo kqxs","kqxs","xo so"].includes(normalized)){
        showHistoryPanel()
        return true
      }
      if(["ve browser","mo browser","dong kqxs","ve trinh duyet","mo trinh duyet"].includes(normalized)){
        showBrowserPanel()
        return true
      }
      if(["che do toi","dark mode","toi"].includes(normalized)){
        setThemeDark(true, true)
        return true
      }
      if(["che do sang","light mode","sang"].includes(normalized)){
        setThemeDark(false, true)
        return true
      }
      if(["bat dich web","bat dich tieng viet","tu dong dich","dich tu dong"].includes(normalized)){
        await translateCurrentWeb()
        return true
      }
      if(["tat dich web","tat dich tieng viet","tat tu dong dich"].includes(normalized)){
        await restoreOriginalWebLanguage()
        return true
      }
      if(["doi giao dien","doi theme"].includes(normalized)){
        toggleTheme()
        return true
      }
      if(["in","in ve","in vung"].includes(normalized)){
        printLatestTicket()
        return true
      }
      if(["lens ocr","ocr","quet ocr","lens+ocr"].includes(normalized)){
        startLensOcr()
        return true
      }
      if(["lens ai","quet ai","lens+ai"].includes(normalized)){
        startLensAi()
        return true
      }
      if(["tieng viet","viet hoa","viet hoa agentgpt","agentgpt tieng viet","bat tieng viet"].includes(normalized)){
        await applyVietnameseForAgentGPT(getActiveWebview(), true)
        return true
      }
      if(["tro giup","help","lenh","huong dan"].includes(normalized)){
        alert("L·ªánh h·ªó tr·ª£: m·ªü AgentGPT/ChatGPT/LotoAI, llama2, alpaca, vicuna, mistral, tinytext, gptq, pull model, pull all, AI Switch, mic, lens ocr, lens ai, d·ªãch web, ng√¥n ng·ªØ g·ªëc, c√†i adb, adb devices, ADB WiFi, mirror usb/wifi, camera usb/wifi, ch·ª•p usb/wifi, m·ªü c√†i ƒë·∫∑t, m·ªü c√¥ng c·ª• AI, quay l·∫°i, ti·∫øn t·ªõi, t·∫£i l·∫°i, m·ªü KQXS, v·ªÅ tr√¨nh duy·ªát, ch·∫ø ƒë·ªô t·ªëi, ch·∫ø ƒë·ªô s√°ng, ti·∫øng vi·ªát, zoom 120, m·ªü google.com, t√¨m <t·ª´ kh√≥a>.")
        return true
      }

      const zoomMatch = normalized.match(/(?:zoom|phong to|co trang)\s*(\d{2,3})/)
      if(zoomMatch){
        document.getElementById("zoomPercent").value = zoomMatch[1]
        applyZoom()
        return true
      }
      if(["phong to","zoom in"].includes(normalized)){
        zoomStep(10)
        return true
      }
      if(["thu nho","zoom out"].includes(normalized)){
        zoomStep(-10)
        return true
      }

      if(normalized.startsWith("tim ")){
        const query = command.slice(4).trim()
        if(query){
          navigateTo(`https://www.google.com/search?q=${encodeURIComponent(query)}`)
          return true
        }
      }

      if(normalized.startsWith("mo ")){
        const target = command.slice(3).trim()
        if(target){
          const normalizedTarget = normalizeVietnameseCommand(target)
          const matchedTool = getEnabledTools().find((tool)=>normalizeVietnameseCommand(tool.name) === normalizedTarget)
          if(matchedTool){
            openAiToolById(matchedTool.id)
            return true
          }
          navigateTo(normalizeNavigationInput(target))
          return true
        }
      }

      return false
    }

    async function openUrl(){
        const raw = document.getElementById("url").value
        if(await executeVietnameseCommand(raw)){
          return
        }
        if(await executeAiControlCommand(raw, { source: "input" })){
          return
        }
        const url = normalizeNavigationInput(raw)
        navigateTo(url)
    }

    function goBack(){getActiveWebview()?.goBack()}
    function goForward(){getActiveWebview()?.goForward()}
    function reload(){getActiveWebview()?.reload()}
    function toggleTheme(){
      const toDark = !document.documentElement.classList.contains("dark")
      setThemeDark(toDark, true)
    }
    function getActiveWebview(){return document.getElementById("mainWebview")}

    function attachWebviewEvents(web){
      if(!web || web.dataset.eventsBound === "1"){
        return
      }

      web.dataset.eventsBound = "1"
      web.addEventListener("dom-ready", ()=>{
        applyZoom()
        const currentUrl = web.getURL?.() || web.src || ""
        updateUrlInput(getDisplayUrl(currentUrl))
        ensureVietnameseTranslation(web, currentUrl)
        scheduleAgentGPTEnhancement(web)
      })
      web.addEventListener("did-stop-loading", ()=>{
        scheduleAgentGPTEnhancement(web)
      })
      web.addEventListener("did-navigate", (event)=>{
        const currentUrl = event?.url || web.getURL?.() || web.src || ""
        updateUrlInput(getDisplayUrl(currentUrl))
        ensureVietnameseTranslation(web, currentUrl)
        scheduleAgentGPTEnhancement(web)
      })
      web.addEventListener("did-navigate-in-page", (event)=>{
        const currentUrl = event?.url || web.getURL?.() || web.src || ""
        updateUrlInput(getDisplayUrl(currentUrl))
        ensureVietnameseTranslation(web, currentUrl)
        scheduleAgentGPTEnhancement(web)
      })
    }

    function applyZoom(){
      const web = getActiveWebview()
      if(!web){
        return
      }
      if(typeof web.setZoomFactor !== "function"){
        return
      }
      const input = document.getElementById("zoomPercent")
      let percent = Number(input.value || 100)
      if(!Number.isFinite(percent)) percent = 100
      percent = Math.max(30, Math.min(300, percent))
      input.value = String(percent)
      web.setZoomFactor(percent / 100)
    }

    function zoomStep(step){
      const input = document.getElementById("zoomPercent")
      const current = Number(input.value || 100)
      input.value = String((Number.isFinite(current) ? current : 100) + step)
      applyZoom()
    }
    function toggleHistoryPanel(){
      const panel = document.getElementById("historyWrap")
      const main = document.querySelector(".main")
      const btn = document.getElementById("toggleHistoryBtn")
      const showKQXS = panel.classList.contains("hidden")

      if(showKQXS){
        panel.classList.remove("hidden")
        panel.classList.add("full-view")
        main.classList.add("hidden")
        btn.textContent = "V·ªÅ tr√¨nh duy·ªát"
        loadKQXSData()
      }else{
        panel.classList.add("hidden")
        panel.classList.remove("full-view")
        main.classList.remove("hidden")
        btn.textContent = "KQXS"
      }
    }

    function escapeHtml(text){
      return String(text || "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;")
    }

    const STATION_DISPLAY_MAP = {
      "an giang": "An Giang",
      "bac lieu": "B·∫°c Li√™u",
      "ben tre": "B·∫øn Tre",
      "binh duong": "B√¨nh D∆∞∆°ng",
      "binh phuoc": "B√¨nh Ph∆∞·ªõc",
      "binh thuan": "B√¨nh Thu·∫≠n",
      "ca mau": "C√† Mau",
      "can tho": "C·∫ßn Th∆°",
      "da lat": "ƒê√† L·∫°t",
      "dong nai": "ƒê·ªìng Nai",
      "dong thap": "ƒê·ªìng Th√°p",
      "hau giang": "H·∫≠u Giang",
      "kien giang": "Ki√™n Giang",
      "long an": "Long An",
      "mien nam": "Mi·ªÅn Nam",
      "mien trung": "Mi·ªÅn Trung",
      "mien bac": "Mi·ªÅn B·∫Øc",
      "soc trang": "S√≥c TrƒÉng",
      "tay ninh": "T√¢y Ninh",
      "tien giang": "Ti·ªÅn Giang",
      "tp hcm": "TP HCM",
      "tphcm": "TP HCM",
      "ho chi minh": "TP HCM",
      "tra vinh": "Tr√† Vinh",
      "vinh long": "Vƒ©nh Long",
      "vung tau": "V≈©ng T√†u",
      "ba ria vung tau": "V≈©ng T√†u",
      "brvt": "V≈©ng T√†u"
    }

    function normalizeStationToken(text){
      return String(text || "")
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/ƒë/g, "d")
        .replace(/ƒê/g, "d")
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, " ")
        .replace(/\s+/g, " ")
        .trim()
    }

    function toTitleWords(text){
      return String(text || "")
        .split(/\s+/g)
        .filter(Boolean)
        .map((word)=>word.charAt(0).toUpperCase() + word.slice(1))
        .join(" ")
    }

    function displayStationName(station){
      const raw = String(station || "").trim()
      if(!raw){
        return "Ch∆∞a r√µ ƒë√†i"
      }
      const normalized = normalizeStationToken(raw)
      if(normalized === "thu cong" || normalized === "khong ro dai"){
        return "Ch∆∞a r√µ ƒë√†i"
      }
      if(STATION_DISPLAY_MAP[normalized]){
        return STATION_DISPLAY_MAP[normalized]
      }

      const parts = raw
        .split(/\s*[|,;]\s*|\s*\.\s*/g)
        .map((item)=>item.trim())
        .filter(Boolean)

      if(!parts.length){
        return raw
      }

      const formatted = parts.map((part)=>{
        const key = normalizeStationToken(part)
        if(STATION_DISPLAY_MAP[key]){
          return STATION_DISPLAY_MAP[key]
        }
        if(part === part.toLowerCase()){
          return toTitleWords(part)
        }
        return part
      })

      return formatted.join(" | ")
    }

    async function collectStationHint(){
      const web = getActiveWebview()
      if(!web){
        return {}
      }

      try{
        const hint = await web.executeJavaScript(`
          (() => ({
            title: document.title || "",
            url: location.href || "",
            hostname: location.hostname || ""
          }))()
        `)
        return hint && typeof hint === "object" ? hint : {}
      }catch(e){
        return {}
      }
    }

    function formatCopiedLayout(rawText){
      return `<pre class="copy-raw">${escapeHtml(rawText || "")}</pre>`
    }

    function formatTicketLayout(item, index, forPrint=false){
      const ticket = item?.ticket || {}
      const rows = Array.isArray(ticket.prizes) ? ticket.prizes : []
      if(!rows.length){
        return formatCopiedLayout(item?.rawText || "")
      }

      const station = displayStationName(ticket.station || "Ch∆∞a r√µ ƒë√†i")
      const drawDate = ticket.drawDate || ""
      const bodyRows = rows.map((row)=>{
        const values = Array.isArray(row.numbers) ? row.numbers.join("  ") : ""
        return `<tr><td>${escapeHtml(row.label || row.key || "")}</td><td>${escapeHtml(values)}</td></tr>`
      }).join("")

      return `
        <div class="ticket-card">
          <div class="ticket-head">V√© d√≤ KQXS</div>
          ${forPrint ? "" : `<div class="ticket-tools"><button class="print-ticket-btn" onclick="printTicketByIndex(${index})">IN</button></div>`}
          <div class="ticket-meta">ƒê√†i: ${escapeHtml(station)}${drawDate ? ` | Ng√†y: ${escapeHtml(drawDate)}` : ""}</div>
          <table class="ticket-table">
            <thead><tr><th>Gi·∫£i</th><th>K·∫øt qu·∫£</th></tr></thead>
            <tbody>${bodyRows}</tbody>
          </table>
        </div>
      `
    }

    function openManualScanModal(){
      document.getElementById("manualScanModal").classList.add("show")
      const input = document.getElementById("manualScanInput")
      input.focus()
    }

    function closeManualScanModal(){
      document.getElementById("manualScanModal").classList.remove("show")
      document.getElementById("manualScanInput").value = ""
    }

    async function pasteFromClipboard(){
      try{
        const text = await navigator.clipboard.readText()
        const textarea = document.getElementById("manualScanInput")
        textarea.value = text
        textarea.focus()
      }catch(e){
        alert("Kh√¥ng th·ªÉ ƒë·ªçc clipboard: " + e.message)
      }
    }

    async function pasteImageFromClipboard(){
      try{
        const items = await navigator.clipboard.read()
        for(const item of items){
          for(const type of item.types){
            if(type.startsWith("image/")){
              const blob = await item.getType(type)
              await processKqxsImage(blob)
              return
            }
          }
        }
        alert("Kh√¥ng c√≥ ·∫£nh trong clipboard.")
      }catch(e){
        alert("Kh√¥ng th·ªÉ d√°n ·∫£nh: " + e.message + "\nVui l√≤ng ch·ª•p m√†n h√¨nh v√† d√°n (Ctrl+V).")
      }
    }

    async function openFileForKqxs(){
      try{
        const res = await ipcRenderer.invoke("dialog:open-file", {
          filters: [
            { name: "Images", extensions: ["png", "jpg", "jpeg", "gif", "bmp", "webp"] },
            { name: "Text", extensions: ["txt", "csv"] },
            { name: "All Files", extensions: ["*"] }
          ]
        })
        
        if(res?.canceled || !res?.filePaths?.length){
          return
        }
        
        const filePath = res.filePaths[0]
        const ext = filePath.split(".").pop().toLowerCase()
        
        if(["png", "jpg", "jpeg", "gif", "bmp", "webp"].includes(ext)){
          const fileRes = await ipcRenderer.invoke("fs:read-file", { path: filePath })
          if(!fileRes?.ok){
            alert("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c file: " + fileRes?.error)
            return
          }
          const data = new Uint8Array(fileRes.data)
          await processKqxsImage(new Blob([data], { type: `image/${ext}` }))
        }else{
          const textRes = await ipcRenderer.invoke("fs:read-file-text", { path: filePath })
          if(!textRes?.ok){
            alert("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c file: " + textRes?.error)
            return
          }
          document.getElementById("manualScanInput").value = textRes.text
        }
      }catch(e){
        alert("L·ªói m·ªü file: " + e.message)
      }
    }

    function clearManualScanInput(){
      document.getElementById("manualScanInput").value = ""
    }

    function openLensResultModal({ title, meta, text }){
      lensResultState = {
        title: String(title || "K·∫øt qu·∫£ Lens"),
        meta: String(meta || ""),
        text: String(text || "")
      }

      document.getElementById("lensResultTitle").textContent = lensResultState.title
      document.getElementById("lensResultMeta").textContent = lensResultState.meta
      document.getElementById("lensResultInput").value = lensResultState.text
      document.getElementById("lensResultModal").classList.add("show")
    }

    function closeLensResultModal(){
      document.getElementById("lensResultModal").classList.remove("show")
    }

    function adjustLensFontSize(delta){
      lensEditorState.fontSize = Math.max(10, Math.min(32, lensEditorState.fontSize + delta))
      const input = document.getElementById("lensResultInput")
      input.style.fontSize = `${lensEditorState.fontSize}px`
      document.getElementById("lensFontSizeLabel").textContent = `${lensEditorState.fontSize}px`
    }

    function toggleLensFullView(){
      lensEditorState.fullscreen = !lensEditorState.fullscreen
      const input = document.getElementById("lensResultInput")
      const toolbar = document.querySelector(".lens-editor-toolbar")
      if(lensEditorState.fullscreen){
        input.classList.add("lens-fullscreen")
        toolbar.classList.add("active")
      }else{
        input.classList.remove("lens-fullscreen")
        toolbar.classList.remove("active")
      }
    }

    function toggleLensEditMode(){
      lensEditorState.editMode = !lensEditorState.editMode
      const input = document.getElementById("lensResultInput")
      if(lensEditorState.editMode){
        input.classList.add("lens-edit-mode")
        input.focus()
      }else{
        input.classList.remove("lens-edit-mode")
      }
    }

    async function analyzeLensWithAI(){
      const text = String(document.getElementById("lensResultInput").value || "").trim()
      if(!text){
        alert("Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ ph√¢n t√≠ch")
        return
      }

      const modal = document.getElementById("lensResultModal")
      modal.classList.remove("show")
      
      setTimeout(() => {
        openLotoAi()
        setTimeout(() => {
          const input = document.getElementById("lotoAiInput")
          if(input){
            input.value = `Ph√¢n t√≠ch KQXS sau ƒë√¢y:\n${text}\n\nH√£y ph√¢n t√≠ch c√°c con s·ªë may m·∫Øn, t·∫ßn su·∫•t xu·∫•t hi·ªán, v√† ƒë∆∞a ra d·ª± ƒëo√°n.`
            input.focus()
          }
        }, 500)
      }, 300)
    }

    async function copyLensResultText(){
      const text = String(document.getElementById("lensResultInput").value || "").trim()
      if(!text){
        alert("Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ ch√©p")
        return
      }
      try{
        if(navigator.clipboard?.writeText){
          await navigator.clipboard.writeText(text)
        }else{
          const input = document.getElementById("lensResultInput")
          input.focus()
          input.select()
          document.execCommand("copy")
        }
        alert("ƒê√£ ch√©p n·ªôi dung lens.")
      }catch(_e){
        alert("Kh√¥ng th·ªÉ ch√©p n·ªôi dung lens")
      }
    }

    async function saveLensResultToHistory(){
      const text = String(document.getElementById("lensResultInput").value || "").trim()
      if(!text){
        alert("Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ l∆∞u")
        return
      }

      try{
        const stationHint = await collectStationHint()
        const res = await ipcRenderer.invoke("kqxs:save-manual-copy", { text, stationHint })
        if(!res || !res.ok){
          alert(res?.error || "L∆∞u n·ªôi dung lens th·∫•t b·∫°i")
          return
        }
        applySavedResult(res)
        alert("ƒê√£ l∆∞u v√†o l·ªãch s·ª≠ KQXS.")
      }catch(_e){
        alert("L∆∞u n·ªôi dung lens th·∫•t b·∫°i")
      }
    }

    async function saveManualScanText(){
      const rawText = document.getElementById("manualScanInput").value
      const text = String(rawText || "").trim()
      if(!text){
        alert("B·∫°n ch∆∞a nh·∫≠p n·ªôi dung ƒë·ªÉ qu√©t")
        return
      }

      try{
        const stationHint = await collectStationHint()
        const res = await ipcRenderer.invoke("kqxs:save-manual-copy", { text: rawText, stationHint })
        if(!res || !res.ok){
          alert(res?.error || "L∆∞u n·ªôi dung th·∫•t b·∫°i")
          return
        }
        applySavedResult(res)
        closeManualScanModal()
      }catch(e){
        alert("L∆∞u n·ªôi dung th·∫•t b·∫°i")
      }
    }

    function applySavedResult(res){
      renderKQXSHistory(res?.history || [])
      renderTopStats(res?.topByStation || [])
    }

    async function printLatestTicket(){
      if(document.querySelector(".main").classList.contains("hidden")){
        toggleHistoryPanel()
      }
      startLensRegionMode("print")
    }

    async function startLensOcr(){
      if(document.querySelector(".main").classList.contains("hidden")){
        toggleHistoryPanel()
      }
      startLensRegionMode("ocr")
    }

    async function startLensAi(){
      if(document.querySelector(".main").classList.contains("hidden")){
        toggleHistoryPanel()
      }
      startLensRegionMode("ai")
    }

    function getLensModeTip(mode){
      if(mode === "ocr"){
        return "Lens+OCR: K√©o khoanh v√πng ƒë·ªÉ nh·∫≠n di·ªán ch·ªØ trong ·∫£nh. Nh·∫•n ESC ƒë·ªÉ hu·ª∑."
      }
      if(mode === "ai"){
        return "Lens+AI: K√©o khoanh v√πng ƒë·ªÉ AI x·ª≠ l√Ω n·ªôi dung. Nh·∫•n ESC ƒë·ªÉ hu·ª∑."
      }
      return "Lens+IN: K√©o khoanh v√πng c·∫ßn in. N·ªôi dung qu√©t s·∫Ω t·ª± th·ª≠ l∆∞u l·ªãch s·ª≠ KQXS. Nh·∫•n ESC ƒë·ªÉ hu·ª∑."
    }

    function startLensRegionMode(mode){
      if(lensRegionState){
        return
      }

      const web = getActiveWebview()
      const main = document.querySelector(".main")
      if(!web || !main){
        alert("Kh√¥ng t√¨m th·∫•y trang web ƒë·ªÉ qu√©t")
        return
      }

      const overlay = document.createElement("div")
      overlay.className = "print-region-overlay"
      overlay.innerHTML = `
        <div class="print-region-tip">${escapeHtml(getLensModeTip(mode))}</div>
        <div class="print-region-box"></div>
      `

      const box = overlay.querySelector(".print-region-box")
      let dragging = false
      let startX = 0
      let startY = 0

      function getLocalPoint(event){
        const rect = overlay.getBoundingClientRect()
        return {
          x: Math.max(0, Math.min(rect.width, event.clientX - rect.left)),
          y: Math.max(0, Math.min(rect.height, event.clientY - rect.top))
        }
      }

      function drawBox(x, y, w, h){
        box.style.display = "block"
        box.style.left = `${x}px`
        box.style.top = `${y}px`
        box.style.width = `${w}px`
        box.style.height = `${h}px`
      }

      const onMouseDown = (event)=>{
        dragging = true
        const p = getLocalPoint(event)
        startX = p.x
        startY = p.y
        drawBox(startX, startY, 0, 0)
      }

      const onMouseMove = (event)=>{
        if(!dragging){
          return
        }
        const p = getLocalPoint(event)
        const left = Math.min(startX, p.x)
        const top = Math.min(startY, p.y)
        const width = Math.abs(p.x - startX)
        const height = Math.abs(p.y - startY)
        drawBox(left, top, width, height)
      }

      const onMouseUp = async (event)=>{
        if(!dragging){
          return
        }
        dragging = false

        const p = getLocalPoint(event)
        const left = Math.min(startX, p.x)
        const top = Math.min(startY, p.y)
        const width = Math.abs(p.x - startX)
        const height = Math.abs(p.y - startY)

        if(width < 12 || height < 12){
          cancelLensRegionMode()
          return
        }

        await captureLensRegion(mode, { left, top, width, height }, overlay, web)
      }

      const onKeyDown = (event)=>{
        if(event.key === "Escape"){
          cancelLensRegionMode()
        }
      }

      overlay.addEventListener("mousedown", onMouseDown)
      overlay.addEventListener("mousemove", onMouseMove)
      overlay.addEventListener("mouseup", onMouseUp)
      window.addEventListener("keydown", onKeyDown)
      main.appendChild(overlay)

      lensRegionState = {
        mode,
        overlay,
        onMouseDown,
        onMouseMove,
        onMouseUp,
        onKeyDown
      }
    }

    function cancelLensRegionMode(){
      if(!lensRegionState){
        return
      }

      const { overlay, onMouseDown, onMouseMove, onMouseUp, onKeyDown } = lensRegionState
      overlay.removeEventListener("mousedown", onMouseDown)
      overlay.removeEventListener("mousemove", onMouseMove)
      overlay.removeEventListener("mouseup", onMouseUp)
      window.removeEventListener("keydown", onKeyDown)
      overlay.remove()
      lensRegionState = null
    }

    function resolveCaptureRect(rect, overlay, web){
      const overlayRect = overlay.getBoundingClientRect()
      const webRect = web.getBoundingClientRect()

      const globalLeft = overlayRect.left + rect.left
      const globalTop = overlayRect.top + rect.top
      const x = Math.max(0, Math.round(globalLeft - webRect.left))
      const y = Math.max(0, Math.round(globalTop - webRect.top))
      const width = Math.min(Math.round(rect.width), Math.max(1, Math.round(webRect.width - x)))
      const height = Math.min(Math.round(rect.height), Math.max(1, Math.round(webRect.height - y)))

      if(width < 5 || height < 5){
        return null
      }

      return { x, y, width, height }
    }

    function scoreLensText(text){
      const value = String(text || "").trim()
      if(!value) return 0
      const digitCount = (value.match(/\d/g) || []).length
      return value.length + digitCount * 4
    }

    function pickBestLensText(primary, secondary){
      const first = String(primary || "").trim()
      const second = String(secondary || "").trim()
      if(scoreLensText(second) > scoreLensText(first)){
        return second
      }
      return first
    }

    async function saveScannedTextToHistory(rawText, stationHint){
      const text = String(rawText || "").trim()
      if(!text){
        return { ok: false, error: "N·ªôi dung qu√©t tr·ªëng" }
      }

      try{
        const saveRes = await ipcRenderer.invoke("kqxs:save-manual-copy", { text, stationHint })
        if(saveRes?.ok){
          applySavedResult(saveRes)
          return { ok: true }
        }
        return { ok: false, error: saveRes?.error || "L∆∞u l·ªãch s·ª≠ th·∫•t b·∫°i" }
      }catch(e){
        return { ok: false, error: e?.message || "L∆∞u l·ªãch s·ª≠ th·∫•t b·∫°i" }
      }
    }

    async function runLensOcrByAi(imageDataUrl){
      try{
        const res = await ipcRenderer.invoke("lens:ocr-image", { imageDataUrl })
        if(!res || !res.ok){
          return { ok: false, text: "", error: res?.error || "OCR th·∫•t b·∫°i" }
        }
        return { ok: true, text: String(res.text || "").trim(), error: "" }
      }catch(e){
        return { ok: false, text: "", error: e?.message || "OCR th·∫•t b·∫°i" }
      }
    }

    async function runLensAiProcess(imageDataUrl, textHint){
      try{
        const res = await ipcRenderer.invoke("lens:ai-process", {
          imageDataUrl,
          textHint,
          instruction: "X·ª≠ l√Ω n·ªôi dung v√πng qu√©t ƒë·ªÉ h·ªó tr·ª£ ƒë·ªçc k·∫øt qu·∫£ x·ªï s·ªë v√† ƒë·ªëi chi·∫øu v√©."
        })
        if(!res || !res.ok){
          return { ok: false, result: "", error: res?.error || "AI x·ª≠ l√Ω th·∫•t b·∫°i" }
        }
        return { ok: true, result: String(res.result || "").trim(), error: "" }
      }catch(e){
        return { ok: false, result: "", error: e?.message || "AI x·ª≠ l√Ω th·∫•t b·∫°i" }
      }
    }

    async function captureLensRegion(mode, rect, overlay, web){
      try{
        const captureRect = resolveCaptureRect(rect, overlay, web)
        if(!captureRect){
          alert("V√πng qu√©t kh√¥ng h·ª£p l·ªá")
          return
        }

        const stationHint = await collectStationHint()
        const extractedDomText = await extractTextFromRegion(web, captureRect)
        const image = await web.capturePage(captureRect)
        const imageDataUrl = `data:image/png;base64,${image.toPNG().toString("base64")}`

        if(mode === "print"){
          if(extractedDomText){
            await saveScannedTextToHistory(extractedDomText, stationHint)
          }
          const jpegDataUrl = `data:image/jpeg;base64,${image.toJPEG(92).toString("base64")}`
          printImageDataUrl(jpegDataUrl)
          return
        }

        const ocrRes = await runLensOcrByAi(imageDataUrl)
        const recognizedText = pickBestLensText(extractedDomText, ocrRes.text)
        const savedRes = recognizedText
          ? await saveScannedTextToHistory(recognizedText, stationHint)
          : { ok: false, error: "Kh√¥ng c√≥ d·ªØ li·ªáu text ƒë·ªÉ l∆∞u l·ªãch s·ª≠" }

        if(mode === "ocr"){
          const metaLines = []
          if(ocrRes.ok){
            metaLines.push("OCR th√†nh c√¥ng.")
          }else{
            metaLines.push(`OCR l·ªói: ${ocrRes.error}`)
          }
          if(savedRes.ok){
            metaLines.push("ƒê√£ t·ª± l∆∞u v√†o l·ªãch s·ª≠ KQXS.")
          }else if(recognizedText){
            metaLines.push(`Kh√¥ng t·ª± l∆∞u ƒë∆∞·ª£c l·ªãch s·ª≠: ${savedRes.error}`)
          }

          openLensResultModal({
            title: "K·∫øt qu·∫£ Lens+OCR",
            meta: metaLines.join("\n"),
            text: recognizedText || "(Kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c n·ªôi dung)"
          })
          return
        }

        const aiRes = await runLensAiProcess(imageDataUrl, recognizedText)
        const metaLines = []
        if(savedRes.ok){
          metaLines.push("ƒê√£ t·ª± l∆∞u text v√πng qu√©t v√†o l·ªãch s·ª≠ KQXS.")
        }else if(recognizedText){
          metaLines.push(`Ch∆∞a t·ª± l∆∞u ƒë∆∞·ª£c l·ªãch s·ª≠ KQXS: ${savedRes.error}`)
        }
        if(!aiRes.ok){
          metaLines.push(`AI l·ªói: ${aiRes.error}`)
        }

        openLensResultModal({
          title: "K·∫øt qu·∫£ Lens+AI",
          meta: metaLines.join("\n"),
          text: aiRes.ok
            ? aiRes.result
            : (recognizedText || "Kh√¥ng c√≥ k·∫øt qu·∫£ AI.")
        })
      }catch(e){
        alert("Kh√¥ng th·ªÉ x·ª≠ l√Ω v√πng qu√©t")
      }finally{
        cancelLensRegionMode()
      }
    }

    async function extractTextFromRegion(web, region){
      const safeRegion = {
        x: Math.max(0, Math.round(region.x || 0)),
        y: Math.max(0, Math.round(region.y || 0)),
        width: Math.max(1, Math.round(region.width || 1)),
        height: Math.max(1, Math.round(region.height || 1))
      }

      try{
        const regionJson = JSON.stringify(safeRegion)
        const text = await web.executeJavaScript(`
          (() => {
            const region = ${regionJson}
            const rx2 = region.x + region.width
            const ry2 = region.y + region.height

            const intersects = (r) => !(r.right < region.x || r.left > rx2 || r.bottom < region.y || r.top > ry2)
            const isVisible = (el) => {
              const s = window.getComputedStyle(el)
              if (s.display === "none" || s.visibility === "hidden" || Number(s.opacity || "1") === 0) return false
              const r = el.getBoundingClientRect()
              return r.width > 0 && r.height > 0
            }

            const nodes = []
            document.querySelectorAll("body *").forEach((el) => {
              if (!isVisible(el)) return
              const rect = el.getBoundingClientRect()
              if (!intersects(rect)) return
              if (el.children.length > 0) return
              const text = String(el.innerText || el.textContent || "").replace(/\\s+/g, " ").trim()
              if (!text) return
              nodes.push({ text, top: rect.top, left: rect.left })
            })

            nodes.sort((a, b) => (a.top - b.top) || (a.left - b.left))
            const lines = []
            let prev = ""
            nodes.forEach((n) => {
              if (n.text === prev) return
              lines.push(n.text)
              prev = n.text
            })

            return lines.join("\\n").trim()
          })()
        `)

        return String(text || "").trim()
      }catch(_err){
        return ""
      }
    }

    function printImageDataUrl(dataUrl){
      const printWindow = window.open("", "_blank", "width=1000,height=760")
      if(!printWindow){
        alert("Kh√¥ng m·ªü ƒë∆∞·ª£c c·ª≠a s·ªï in")
        return
      }

      printWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <title>In V√πng ƒê√£ Khoanh</title>
          <style>
            html,body{margin:0;padding:0;background:#fff}
            .wrap{padding:12px}
            img{
              display:block;
              max-width:100%;
              height:auto;
              -webkit-print-color-adjust: exact;
              print-color-adjust: exact;
            }
            @media print{
              .wrap{padding:0}
            }
          </style>
        </head>
        <body>
          <div class="wrap"><img src="${dataUrl}" alt="Vung in"/></div>
        </body>
        </html>
      `)
      printWindow.document.close()
      printWindow.focus()
      setTimeout(()=>{
        printWindow.print()
        printWindow.close()
      }, 250)
    }

    function printTicketByIndex(index){
      const item = latestHistory[index]
      if(!item || !item.ticket || !Array.isArray(item.ticket.prizes) || !item.ticket.prizes.length){
        alert("Kh√¥ng t√¨m th·∫•y b·∫£ng KQXS ƒë·ªÉ in")
        return
      }

      const printContent = formatTicketLayout(item, index, true)
      const printWindow = window.open("", "_blank", "width=900,height=700")
      if(!printWindow){
        alert("Kh√¥ng m·ªü ƒë∆∞·ª£c c·ª≠a s·ªï in")
        return
      }

      printWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <title>In V√© D√≤ KQXS</title>
          <style>
            body{font-family:Arial,sans-serif;padding:16px;color:#111}
            .ticket-card{border:1px solid #cbd5e1;border-radius:8px;padding:8px}
            .ticket-head{font-weight:700;margin-bottom:6px}
            .ticket-meta{font-size:12px;margin-bottom:6px}
            .ticket-table{width:100%;border-collapse:collapse}
            .ticket-table th,.ticket-table td{border:1px solid #cbd5e1;padding:6px;text-align:left}
            .ticket-table th{background:#f1f5f9}
          </style>
        </head>
        <body>
          ${printContent}
        </body>
        </html>
      `)
      printWindow.document.close()
      printWindow.focus()
      setTimeout(()=>{
        printWindow.print()
        printWindow.close()
      }, 250)
    }

    const PRIZE_ORDER = ["g8","g7","g6","g5","g4","g3","g2","g1","gdb"]
    const PRIZE_LABEL = { g8:"G8", g7:"G7", g6:"G6", g5:"G5", g4:"G4", g3:"G3", g2:"G2", g1:"G1", gdb:"ƒêB" }

    function normalizePrizeKeyFromRow(row){
      const key = String(row?.key || "").toLowerCase()
      if(PRIZE_ORDER.includes(key)){
        return key
      }
      const label = String(row?.label || "").toUpperCase().replace(/\s+/g,"")
      if(label === "ƒêB" || label === "DB"){
        return "gdb"
      }
      const m = label.match(/^G([1-8])$/)
      return m ? `g${m[1]}` : ""
    }

    function findNumbersByPrize(ticket, prizeKey){
      const rows = Array.isArray(ticket?.prizes) ? ticket.prizes : []
      for(const row of rows){
        if(normalizePrizeKeyFromRow(row) === prizeKey){
          return Array.isArray(row.numbers) ? row.numbers : []
        }
      }
      return []
    }

    function renderResultNumbers(numbers, prizeKey){
      const safeList = (Array.isArray(numbers) ? numbers : []).map((n)=>escapeHtml(String(n || ""))).filter(Boolean)
      const cls = prizeKey === "gdb" || prizeKey === "g7" ? `${prizeKey} db` : prizeKey
      if(!safeList.length){
        return `<div class="result-values ${cls}">-</div>`
      }
      return `<div class="result-values ${cls}">${safeList.join("<br>")}</div>`
    }

    function resolveDrawTitle(item){
      const ticketDate = String(item?.ticket?.drawDate || "").trim()
      if(ticketDate){
        return ticketDate
      }
      const iso = String(item?.date || "").trim()
      if(!iso){
        return "Ch∆∞a r√µ ng√†y"
      }
      const d = new Date(iso)
      if(Number.isNaN(d.getTime())){
        return iso
      }
      const dd = String(d.getDate()).padStart(2,"0")
      const mm = String(d.getMonth()+1).padStart(2,"0")
      const yyyy = d.getFullYear()
      return `${dd}/${mm}/${yyyy}`
    }

    function renderKQXSHistory(history){
      latestHistory = Array.isArray(history) ? history : []
      const boardsEl = document.getElementById("historyBoards")
      boardsEl.innerHTML = ""
      if(!Array.isArray(history) || !history.length){
        boardsEl.innerHTML = `<div class="history-draw"><div class="history-draw-title">Ch∆∞a c√≥ l·ªãch s·ª≠ qu√©t</div></div>`
        return
      }

      const tickets = history.filter((item)=>Array.isArray(item?.ticket?.prizes) && item.ticket.prizes.length)
      if(!tickets.length){
        boardsEl.innerHTML = `<div class="history-draw"><div class="history-draw-title">Ch∆∞a c√≥ l·ªãch s·ª≠ b·∫£ng KQXS</div></div>`
        return
      }

      const drawMap = new Map()
      tickets.forEach((item)=>{
        const drawTitle = resolveDrawTitle(item)
        if(!drawMap.has(drawTitle)){
          drawMap.set(drawTitle, [])
        }
        drawMap.get(drawTitle).push(item)
      })

      drawMap.forEach((items, drawTitle)=>{
        const stationMap = new Map()
        items.forEach((item)=>{
          const station = displayStationName(item?.ticket?.station || item?.station || "")
          if(!stationMap.has(station)){
            stationMap.set(station, item)
          }
        })

        const stations = Array.from(stationMap.entries())
        if(!stations.length){
          return
        }

        const headerCols = stations.map(([station])=>`<th>${escapeHtml(station)}</th>`).join("")
        const bodyRows = PRIZE_ORDER.map((prizeKey)=>{
          const cols = stations.map(([,item])=>{
            const nums = findNumbersByPrize(item.ticket, prizeKey)
            return `<td>${renderResultNumbers(nums, prizeKey)}</td>`
          }).join("")
          return `<tr><td class="result-prize">${PRIZE_LABEL[prizeKey]}</td>${cols}</tr>`
        }).join("")

        const drawDiv = document.createElement("div")
        drawDiv.className = "history-draw"
        drawDiv.innerHTML = `
          <div class="history-draw-title">K·∫øt qu·∫£ ƒë√£ l∆∞u ng√†y ${escapeHtml(drawTitle)}</div>
          <table class="result-table">
            <thead><tr><th></th>${headerCols}</tr></thead>
            <tbody>${bodyRows}</tbody>
          </table>
        `
        boardsEl.appendChild(drawDiv)
      })
    }

    function enableKqxsCustomLayout(){
      kqxsLayoutState.enableCustomLayout = !kqxsLayoutState.enableCustomLayout
      
      const boards = document.querySelectorAll(".history-draw table")
      boards.forEach(table => {
        if(kqxsLayoutState.enableCustomLayout){
          table.classList.add("layout-editable")
          makeTableSortable(table)
        }else{
          table.classList.remove("layout-editable")
        }
      })
      
      alert(kqxsLayoutState.enableCustomLayout 
        ? "ƒê√£ b·∫≠t ch·∫ø ƒë·ªô t√πy ch·ªânh b·ªë c·ª•c. K√©o th·∫£ c√°c c·ªôt ƒë·ªÉ s·∫Øp x·∫øp l·∫°i. B·∫•m 'L∆∞u b·ªë c·ª•c' ƒë·ªÉ l∆∞u." 
        : "ƒê√£ t·∫Øt ch·∫ø ƒë·ªô t√πy ch·ªânh b·ªë c·ª•c.")
    }

    function makeTableSortable(table){
      const headers = table.querySelectorAll("thead th")
      headers.forEach((header, index) => {
        if(index === 0) return
        header.style.cursor = "move"
        header.draggable = true
        
        header.addEventListener("dragstart", (e) => {
          e.dataTransfer.setData("text/plain", index)
          header.classList.add("dragging")
        })
        
        header.addEventListener("dragend", () => {
          header.classList.remove("dragging")
        })
        
        header.addEventListener("dragover", (e) => {
          e.preventDefault()
        })
        
        header.addEventListener("drop", (e) => {
          e.preventDefault()
          const fromIndex = parseInt(e.dataTransfer.getData("text/plain"))
          const toIndex = index
          if(fromIndex !== toIndex){
            reorderTableColumns(table, fromIndex, toIndex)
            saveKqxsLayout(table)
          }
        })
      })
    }

    function reorderTableColumns(table, fromIndex, toIndex){
      const rows = table.querySelectorAll("tr")
      rows.forEach(row => {
        const cells = Array.from(row.querySelectorAll("th, td"))
        if(fromIndex < cells.length && toIndex < cells.length){
          const fromCell = cells[fromIndex]
          const toCell = cells[toIndex]
          const temp = fromCell.innerHTML
          fromCell.innerHTML = toCell.innerHTML
          toCell.innerHTML = temp
        }
      })
    }

    function saveKqxsLayout(table){
      const headers = Array.from(table.querySelectorAll("thead th"))
      const order = headers.map((h, i) => ({ index: i, text: h.textContent.trim() }))
      kqxsLayoutState.customLayout = order
      
      try{
        localStorage.setItem("kqxs_custom_layout", JSON.stringify(order))
        appendAdbTerminalOutput("ƒê√£ l∆∞u b·ªë c·ª•c KQXS t√πy ch·ªânh.")
      }catch(_e){}
    }

    function loadKqxsLayout(){
      try{
        const saved = localStorage.getItem("kqxs_custom_layout")
        if(saved){
          kqxsLayoutState.customLayout = JSON.parse(saved)
        }
      }catch(_e){}
    }

    async function aiRecognizeLayout(){
      const historyText = latestHistory.map(item => {
        return `Ng√†y: ${resolveDrawTitle(item)}, ƒê√†i: ${item?.ticket?.station || ""}, KQ: ${JSON.stringify(item?.ticket?.prizes || [])}`
      }).join("\n\n")

      if(!historyText){
        alert("Ch∆∞a c√≥ d·ªØ li·ªáu KQXS ƒë·ªÉ AI nh·∫≠n di·ªán b·ªë c·ª•c.")
        return
      }

      const modal = document.getElementById("lensResultModal")
      document.getElementById("lensResultTitle").textContent = "AI nh·∫≠n di·ªán b·ªë c·ª•c KQXS"
      document.getElementById("lensResultMeta").textContent = "AI ƒëang ph√¢n t√≠ch b·ªë c·ª•c KQXS c·ªßa b·∫°n..."
      document.getElementById("lensResultInput").value = "ƒêang ph√¢n t√≠ch..."
      modal.classList.add("show")

      try{
        const prompt = `D·ª±a tr√™n d·ªØ li·ªáu KQXS sau ƒë√¢y, h√£y:\n1. Nh·∫≠n di·ªán b·ªë c·ª•c hi·ªán t·∫°i\n2. ƒê·ªÅ xu·∫•t b·ªë c·ª•c t·ªëi ∆∞u ƒë·ªÉ ph√¢n t√≠ch\n3. S·∫Øp x·∫øp c√°c ƒë√†i theo th·ª© t·ª± u ti√™n ph√¢n t√≠ch\n\nD·ªØ li·ªáu KQXS:\n${historyText}\n\nH√£y tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát v√† ƒë∆∞a ra ƒë·ªÅ xu·∫•t c·ª• th·ªÉ.`

        const res = await ipcRenderer.invoke("lotoai:chat", {
          provider: appSettings.ai.internalProvider || "ollama",
          model: appSettings.ai.ollamaModel || "llama2:7b",
          messages: [
            { role: "user", content: prompt }
          ]
        })

        if(res?.ok && res.response){
          document.getElementById("lensResultInput").value = res.response
          document.getElementById("lensResultMeta").textContent = "AI ƒë√£ ph√¢n t√≠ch xong b·ªë c·ª•c KQXS."
        }else{
          document.getElementById("lensResultInput").value = "L·ªói: " + (res?.error || "Kh√¥ng th·ªÉ k·∫øt n·ªëi AI")
        }
      }catch(e){
        document.getElementById("lensResultInput").value = "L·ªói: " + e.message
      }
    }

    function copyKqxsSelection(){
      const selected = document.querySelectorAll(".history-draw.selected")
      if(selected.length === 0){
        alert("Ch∆∞a ch·ªçn b·∫£ng ƒë·ªÉ sao ch√©p. B·∫•m v√†o b·∫£ng ƒë·ªÉ ch·ªçn.")
        return
      }
      
      let text = ""
      selected.forEach(draw => {
        const title = draw.querySelector(".history-draw-title")?.textContent || ""
        text += `\n${title}\n`
        const rows = draw.querySelectorAll("tr")
        rows.forEach(row => {
          const cells = Array.from(row.querySelectorAll("th, td")).map(c => c.textContent.trim()).join(" | ")
          text += cells + "\n"
        })
      })
      
      navigator.clipboard.writeText(text).then(() => {
        alert(`ƒê√£ sao ch√©p ${selected.length} b·∫£ng v√†o clipboard.`)
      }).catch(() => {
        alert("Kh√¥ng th·ªÉ sao ch√©p.")
      })
    }

    async function pasteKqxsData(){
      try{
        const text = await navigator.clipboard.readText()
        if(!text || !text.trim()){
          alert("Kh√¥ng c√≥ d·ªØ li·ªáu trong clipboard.")
          return
        }
        
        const modal = document.getElementById("manualScanModal")
        document.getElementById("manualScanInput").value = text
        modal.classList.add("show")
      }catch(e){
        alert("Kh√¥ng th·ªÉ ƒë·ªçc clipboard. Vui l√≤ng c·∫•p quy·ªÅn truy c·∫≠p clipboard.")
      }
    }

    function addKqxsFromImage(){
      alert("Ch·ª©c nƒÉng th√™m t·ª´ ·∫£nh:\n\nB·∫°n c√≥ th·ªÉ:\n1. D√°n ·∫£nh (Ctrl+V) v√†o √¥ nh·∫≠p li·ªáu\n2. S·ª≠ d·ª•ng Lens+OCR ƒë·ªÉ qu√©t ·∫£nh\n3. S·ª≠ d·ª•ng Lens+AI ƒë·ªÉ AI nh·∫≠n di·ªán")
      
      const modal = document.getElementById("manualScanModal")
      modal.classList.add("show")
      
      const textarea = document.getElementById("manualScanInput")
      textarea.focus()
      
      textarea.addEventListener("paste", async (e) => {
        const items = e.clipboardData?.items
        if(!items) return
        
        for(const item of items){
          if(item.type.startsWith("image/")){
            e.preventDefault()
            const blob = item.getAsFile()
            if(blob){
              processKqxsImage(blob)
            }
            break
          }
        }
      }, { once: true })
    }

    async function processKqxsImage(blob){
      try{
        const arrayBuffer = await blob.arrayBuffer()
        const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)))
        
        appendAdbTerminalOutput("ƒêang x·ª≠ l√Ω ·∫£nh KQXS...")
        
        const res = await ipcRenderer.invoke("lens:ocr-image", {
          imageBase64: `data:image/png;base64,${base64}`
        })
        
        if(res?.ok && res.text){
          document.getElementById("manualScanInput").value = res.text
          appendAdbTerminalOutput("ƒê√£ nh·∫≠n di·ªán text t·ª´ ·∫£nh.")
        }else{
          alert("Kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c text t·ª´ ·∫£nh: " + (res?.error || ""))
        }
      }catch(e){
        alert("L·ªói x·ª≠ l√Ω ·∫£nh: " + e.message)
      }
    }

    function deleteKqxsSelection(){
      const selected = document.querySelectorAll(".history-draw.selected")
      if(selected.length === 0){
        alert("Ch∆∞a ch·ªçn b·∫£ng ƒë·ªÉ xo√°. B·∫•m v√†o b·∫£ng ƒë·ªÉ ch·ªçn.")
        return
      }
      
      if(!confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën xo√° ${selected.length} b·∫£ng ƒë√£ ch·ªçn?`)){
        return
      }
      
      selected.forEach(draw => draw.remove())
      
      const remaining = document.querySelectorAll(".history-draw")
      if(remaining.length === 0){
        document.getElementById("historyBoards").innerHTML = `<div class="history-draw"><div class="history-draw-title">Ch∆∞a c√≥ l·ªãch s·ª≠ qu√©t</div></div>`
      }
      
      appendAdbTerminalOutput(`ƒê√£ xo√° ${selected.length} b·∫£ng KQXS.`)
    }

    document.addEventListener("click", (e) => {
      if(kqxsLayoutState.enableCustomLayout){
        const draw = e.target.closest(".history-draw")
        if(draw){
          if(draw.classList.contains("selected")){
            draw.classList.remove("selected")
          }else{
            draw.classList.add("selected")
          }
        }
      }
    })

    document.addEventListener("keydown", async (e) => {
      if(e.ctrlKey || e.metaKey){
        if(e.key === "v" && document.getElementById("historyWrap").classList.contains("hidden") === false){
          const modal = document.getElementById("manualScanModal")
          if(modal.classList.contains("show")){
            return
          }
          
          try{
            const text = await navigator.clipboard.readText()
            if(text){
              document.getElementById("manualScanInput").value = text
              document.getElementById("manualScanModal").classList.add("show")
            }
          }catch(_e){}
        }
      }
    })

    function normalizeKqxsDigits(value){
      return String(value || "").replace(/\D/g, "")
    }

    function increaseCounter(counterMap, key){
      if(!key){
        return
      }
      counterMap.set(key, Number(counterMap.get(key) || 0) + 1)
    }

    function toTopCounterList(counterMap, limit=10){
      return Array.from(counterMap.entries())
        .map(([number, count])=>({ number, count: Number(count || 0) }))
        .sort((a, b)=>{
          if(b.count !== a.count){
            return b.count - a.count
          }
          return String(a.number).localeCompare(String(b.number), "vi")
        })
        .slice(0, limit)
    }

    function formatCounterEntry(entry){
      if(!entry || !entry.number){
        return "-"
      }
      return `${entry.number} (${entry.count} l·∫ßn)`
    }

    function formatCounterSeries(entries, limit=3){
      const series = (Array.isArray(entries) ? entries : [])
        .slice(0, limit)
        .map((entry)=>formatCounterEntry(entry))
      return series.length ? series.join(" | ") : "-"
    }

    function buildLoStatsFromHistory(history){
      const rows = Array.isArray(history) ? history : []
      const tickets = rows.filter((item)=>Array.isArray(item?.ticket?.prizes) && item.ticket.prizes.length)
      const overall = {
        2: new Map(),
        3: new Map(),
        4: new Map()
      }
      const stationMap = new Map()
      let tokenCount = 0

      tickets.forEach((item)=>{
        const station = displayStationName(item?.ticket?.station || item?.station || "")
        if(!stationMap.has(station)){
          stationMap.set(station, {
            2: new Map(),
            3: new Map(),
            4: new Map(),
            tokens: 0
          })
        }
        const stationBucket = stationMap.get(station)
        const prizes = Array.isArray(item?.ticket?.prizes) ? item.ticket.prizes : []
        prizes.forEach((prize)=>{
          const numbers = Array.isArray(prize?.numbers) ? prize.numbers : []
          numbers.forEach((rawNumber)=>{
            const digits = normalizeKqxsDigits(rawNumber)
            if(!digits){
              return
            }
            tokenCount += 1
            stationBucket.tokens += 1
            ;[2,3,4].forEach((length)=>{
              if(digits.length < length){
                return
              }
              const tail = digits.slice(-length)
              increaseCounter(overall[length], tail)
              increaseCounter(stationBucket[length], tail)
            })
          })
        })
      })

      const stationRows = Array.from(stationMap.entries())
        .map(([station, bucket])=>({
          station,
          tokens: Number(bucket.tokens || 0),
          top2: toTopCounterList(bucket[2], 3),
          top3: toTopCounterList(bucket[3], 3),
          top4: toTopCounterList(bucket[4], 3)
        }))
        .filter((row)=>row.top2.length || row.top3.length || row.top4.length)
        .sort((a, b)=>{
          if(b.tokens !== a.tokens){
            return b.tokens - a.tokens
          }
          return a.station.localeCompare(b.station, "vi")
        })

      return {
        tokenCount,
        overallTop: {
          2: toTopCounterList(overall[2], 10),
          3: toTopCounterList(overall[3], 10),
          4: toTopCounterList(overall[4], 10)
        },
        stationRows
      }
    }

    function renderLoTopChips(entries){
      const items = Array.isArray(entries) ? entries : []
      if(!items.length){
        return `<div class="analysis-chip-list"><span class="analysis-chip">Ch∆∞a c√≥ d·ªØ li·ªáu</span></div>`
      }
      return `
        <div class="analysis-chip-list">
          ${items.map((entry)=>`<span class="analysis-chip"><strong>${escapeHtml(entry.number)}</strong>${escapeHtml(String(entry.count || 0))} l·∫ßn</span>`).join("")}
        </div>
      `
    }

    function renderTopStats(top, history){
      const groupsEl = document.getElementById("analysisBoards")
      const note = document.getElementById("topStatsNote")
      groupsEl.innerHTML = ""

      const groups = Array.isArray(top)
        ? top.filter((group)=>Array.isArray(group?.top) && group.top.length)
        : []
      const loStats = buildLoStatsFromHistory(history)
      const hasLoData = Boolean(
        loStats.overallTop[2].length ||
        loStats.overallTop[3].length ||
        loStats.overallTop[4].length
      )

      if(!groups.length && !hasLoData){
        groupsEl.innerHTML = `<div class="analysis-card"><div class="analysis-title">Ch∆∞a c√≥ d·ªØ li·ªáu ph√¢n t√≠ch</div></div>`
        note.textContent = "AI ch∆∞a ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ nh·∫≠n ƒë·ªãnh theo ƒë√†i."
        return
      }

      let best = null
      const stationSummaries = []
      const sections = []

      if(groups.length){
        const TOP_BY_STATION_LIMIT = 3
        const sortedGroups = groups
          .map((group)=>({
            station: displayStationName(group.dai || ""),
            top: group.top.slice(0, TOP_BY_STATION_LIMIT)
          }))
          .sort((a, b)=>a.station.localeCompare(b.station, "vi"))

        let maxRows = 0
        sortedGroups.forEach((group)=>{
          const station = group.station
          const topList = group.top
          if(topList.length > maxRows){
            maxRows = topList.length
          }
          const topOne = topList[0]
          const topNumber = topOne?.number || "-"
          const topCount = Number(topOne?.count || 0)
          stationSummaries.push(`${station}: ${topNumber} (${topCount} l·∫ßn)`)

          topList.forEach((entry)=>{
            const number = entry?.number || ""
            const count = Number(entry?.count || 0)
            if(!best || count > best.count){
              best = { station, number, count }
            }
          })
        })

        maxRows = Math.max(1, Math.min(TOP_BY_STATION_LIMIT, maxRows))
        const headerCols = sortedGroups.map((group)=>`<th>${escapeHtml(group.station)}</th>`).join("")
        const bodyRows = []
        for(let i=0;i<maxRows;i++){
          const cols = sortedGroups.map((group)=>{
            const entry = group.top[i]
            if(!entry){
              return `<td>-</td>`
            }
            const number = String(entry.number || "-")
            const count = Number(entry.count || 0)
            return `<td><span class="analysis-number">${escapeHtml(number)}</span> <span class="analysis-count">(${count} l·∫ßn)</span></td>`
          }).join("")
          bodyRows.push(`<tr><td class="analysis-rank">Top ${i+1}</td>${cols}</tr>`)
        }

        sections.push(`
          <div class="analysis-card analysis-card-wide">
            <div class="analysis-title">Top s·ªë xu·∫•t hi·ªán theo t·ª´ng ƒë√†i</div>
            <table class="analysis-table analysis-columns-table">
              <thead><tr><th>H·∫°ng</th>${headerCols}</tr></thead>
              <tbody>${bodyRows.join("")}</tbody>
            </table>
          </div>
        `)
      }

      if(hasLoData){
        sections.push(`
          <div class="analysis-card analysis-card-wide">
            <div class="analysis-title">AI Ph√¢n T√≠ch Top L√¥ 2 - 3 - 4 S·ªë</div>
            <div class="analysis-smart-grid">
              <div class="ticket-card">
                <div class="analysis-subtitle">Top l√¥ 2 s·ªë</div>
                ${renderLoTopChips(loStats.overallTop[2])}
              </div>
              <div class="ticket-card">
                <div class="analysis-subtitle">Top l√¥ 3 s·ªë</div>
                ${renderLoTopChips(loStats.overallTop[3])}
              </div>
              <div class="ticket-card">
                <div class="analysis-subtitle">Top l√¥ 4 s·ªë</div>
                ${renderLoTopChips(loStats.overallTop[4])}
              </div>
            </div>
          </div>
        `)

        const stationRows = loStats.stationRows.slice(0, 12)
        if(stationRows.length){
          const stationLoRows = stationRows.map((row)=>`
            <tr>
              <td>${escapeHtml(row.station)}</td>
              <td>${escapeHtml(formatCounterSeries(row.top2))}</td>
              <td>${escapeHtml(formatCounterSeries(row.top3))}</td>
              <td>${escapeHtml(formatCounterSeries(row.top4))}</td>
            </tr>
          `).join("")

          sections.push(`
            <div class="analysis-card analysis-card-wide">
              <div class="analysis-title">AI Ph√¢n T√≠ch Theo ƒê√†i (L√¥ 2/3/4)</div>
              <table class="analysis-mini-table">
                <thead>
                  <tr>
                    <th>ƒê√†i</th>
                    <th>Top l√¥ 2 s·ªë</th>
                    <th>Top l√¥ 3 s·ªë</th>
                    <th>Top l√¥ 4 s·ªë</th>
                  </tr>
                </thead>
                <tbody>${stationLoRows}</tbody>
              </table>
            </div>
          `)
        }
      }

      groupsEl.innerHTML = sections.join("")

      const insightLines = []
      if(best){
        insightLines.push(`AI nh·∫≠n ƒë·ªãnh theo ƒë√†i: ${best.station} c√≥ s·ªë n·ªïi b·∫≠t ${best.number} (${best.count} l·∫ßn).`)
      }
      if(hasLoData){
        const top2 = formatCounterEntry(loStats.overallTop[2][0])
        const top3 = formatCounterEntry(loStats.overallTop[3][0])
        const top4 = formatCounterEntry(loStats.overallTop[4][0])
        insightLines.push(`Top to√†n b·ªô: l√¥ 2 s·ªë ${top2}; l√¥ 3 s·ªë ${top3}; l√¥ 4 s·ªë ${top4}.`)
      }
      if(stationSummaries.length){
        insightLines.push(`T·ªïng h·ª£p nhanh theo ƒë√†i: ${stationSummaries.slice(0, 8).join(" | ")}.`)
      }
      if(loStats.tokenCount){
        insightLines.push(`D·ªØ li·ªáu AI ƒë√£ qu√©t ${loStats.tokenCount} c·ª•m s·ªë t·ª´ l·ªãch s·ª≠ KQXS.`)
      }

      note.innerHTML = insightLines.length
        ? insightLines.map((line)=>escapeHtml(line)).join("<br>")
        : "AI ch∆∞a ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ nh·∫≠n ƒë·ªãnh theo ƒë√†i."
    }

    async function loadKQXSData(){
      try{
        const [historyRes, topRes] = await Promise.all([
          ipcRenderer.invoke("kqxs:get-history"),
          ipcRenderer.invoke("kqxs:get-top-by-station")
        ])

        const history = historyRes?.ok ? (historyRes.history || []) : []
        renderKQXSHistory(history)

        if(!topRes || !topRes.ok){
          renderTopStats([], history)
        }else{
          renderTopStats(topRes.topByStation || [], history)
        }
      }catch(e){
        renderKQXSHistory([])
        renderTopStats([], [])
      }
    }

    async function clearKQXSHistory(){
      const ok = confirm("B·∫°n ch·∫Øc ch·∫Øn mu·ªën xo√° to√†n b·ªô l·ªãch s·ª≠ KQXS?")
      if(!ok){
        return
      }

      try{
        const res = await ipcRenderer.invoke("kqxs:clear-history")
        if(!res || !res.ok){
          alert(res?.error || "Xo√° l·ªãch s·ª≠ th·∫•t b·∫°i")
          return
        }
        renderKQXSHistory([])
        renderTopStats(res.topByStation || [], [])
      }catch(e){
        alert("Xo√° l·ªãch s·ª≠ th·∫•t b·∫°i")
      }
    }

    function openStartupAiTool(){
      const startupToolId = String(appSettings.ai.startupToolId || "")
      if(!startupToolId){
        return
      }
      const startupTool = getAiToolById(startupToolId)
      if(startupTool && startupTool.enabled){
        openAiToolById(startupToolId)
        return
      }
      const firstEnabled = getEnabledTools()[0]
      if(firstEnabled){
        openAiToolById(firstEnabled.id)
      }
    }

    const startupWeb = getActiveWebview()
    applyInterfaceSettingsToUi()
    syncAiRuntimeConfig()
    refreshLotoAiModels(false)
    updateMicButton()
    if(startupWeb){
      attachWebviewEvents(startupWeb)
      openStartupAiTool()
    }
    document.getElementById("url").addEventListener("keydown", (event)=>{
      if(event.key === "Enter"){
        event.preventDefault()
        openUrl()
      }
    })
    document.getElementById("lotoAiInput").addEventListener("keydown", (event)=>{
      if(event.key === "Enter" && !event.shiftKey){
        event.preventDefault()
        sendLotoAiMessage()
      }
    })
    document.getElementById("geminiAiInput").addEventListener("keydown", (event)=>{
      if(event.key === "Enter" && !event.shiftKey){
        event.preventDefault()
        sendGeminiAiMessage()
      }
    })
    document.getElementById("adbTerminalInput").addEventListener("keydown", (event)=>{
      if(event.key === "Enter"){
        event.preventDefault()
        runAdbTerminalCommand()
      }
    })
    refreshAdbToolsStatus(false)
    applyZoom()
    loadKQXSData()
    window.addEventListener("beforeunload", ()=>{
      stopVoiceCommand()
    })
</script>

</body>
</html>
